着色器编程最初是软件渲染领域的一门学科，但后来它在硬件渲染中也变得很有用。在本次演示中，我们将尝试涵盖这两个方面。绝大多数代码示例将采用GLSL，这是一种用于GPU着色器编程的着色语言。GLSL与多个广泛可用的平台兼容，便于你自行进行实验。不过，大多数示例也适用于其他着色语言，因为它们都有共同的起源，并且语法类似C语言。 

如果你不了解GLSL，也许可以学习一下。阅读本书并不一定非要懂GLSL，但这是一种非常简单的语言，学起来容易，用起来也很有趣，而且书中自始至终有大量代码示例，你或许想尝试一下。亲自做实验会让阅读变得更有趣，这也是一种很好的学习方式。

## 着色器的概念

让我们从定义“着色器”的含义开始。

从技术核心上讲，着色器实际上不过是一个函数，它将多个值作为输入，并可能产生多个值作为输出。为了实现可重复性和可移植性，该函数必须是确定性的。任何看似 “随机” 的效果都应该是虚幻的，对于相同输入的重复调用，无论在何时何地运行，都应可预测地产生相同的输出。

着色器还需要具备一种结构，使其能够独立于其他点对任意点执行，无需考虑可能会计算哪些其他点，也无需考虑计算顺序。在使用硬件加速时，着色器通常以大规模并行方式执行，使用相同的程序但不同的输入值，同时计算多达数千个输出值。这被称为单指令多数据（SIMD）执行，SIMD是“Single Instruction, Multiple Data”的缩写。 

具有这些特性的函数，其更通用的技术名称是“计算内核”。用于SIMD编程的语言（如OpenCL和CUDA）使用这个术语，但就本次演示而言，我们仍使用“着色器”这一名称。


## 假装画画的艺术

要掌握程序化纹理，你需要重新思考经典计算机图形学的一些基本概念。最难跨越的门槛是要习惯这样一个事实：在着色器程序中，你实际上并没有绘制任何东西。你是在设计一个函数 $F(p)$，它告诉渲染器位置为 $\bar{P}$ 的点应该具有什么颜色（或其他局部属性），但你无法控制绘制哪些像素、以何种顺序绘制或采用何种分辨率。这一切都需要仅使用局部数据在每个像素上独立计算。 

这样的局部数据可以包括表面点的位置、其表面法线、光照信息和纹理映射坐标，还可以包括你想要的任何其他参数，只要这些参数能够明确地提供给着色器。


## GPU 着色器
在传统的基于多边形的硬件辅助渲染中（这仍然是实时内容的标准做法），你需要指定顶点属性，然后这些属性会以透视校正的方式在每个三角形的角点之间进行插值。最基本的GPU着色器结构有两个着色器：顶点着色器(Vertex Shader)和片元着色器(Fragment Shader)，它们协同工作以计算最终输出。下面的图展示了一个稍微简化的数据流和处理模型，其中可编程着色器部分用橙色表示。（实际上，现在所有类型的着色器都是由同一组通用内核执行的——这里的区分是概念上的，而非物理上的。）
![2504285524 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/04/28/1mg/2504285524-.png)
*A useful, simplified model of the data flow in a shader-capable GPU. The terminology used for the labels is from OpenGL and GLSL*

顶点着色器对三角形顶点数据进行操作，其输入为顶点的位置以及诸如表面法线和纹理映射坐标等任何其他属性。它的职责是在变换后计算顶点的最终屏幕空间位置和法线，并且可能还会修改一些其他属性。

片段着色器在像素级别上运行。它之所以不被称为“像素着色器”，是因为如果采用多重采样，着色器会为每个像素执行多次，然后将结果进行平均以生成最终输出。这个术语并不是非常明确，虽然GLSL使用“片段着色器”这个名称，但HLSL实际上将其称为“像素着色器”。

从潜在角度而言，为了提高速度，片段着色器对每个像素的运行次数可能会比一次更稀疏，并且其输出会进行插值处理，尽管这在当前的GPU架构中并不可行。然而，在程序化软件着色中，这却是一种可行的方法，其中“着色率”可以有所变化，从每个像素进行几次平均着色器求值，到每隔几个像素进行一次共享并插值的求值。这与渲染到较低分辨率然后进行上采样有所不同，因为物体边界仍然是以全分辨率进行渲染的。 


## Software Shaders

在软件渲染中，最初的 Renderman 接口定义了几种类型的 RSL 着色器，这里最相关的是Displacement shaders和surface shaders。它们大致相当于基于 GPU 的顶点着色器和片元着色器，但有一些区别。一个特别重要的区别是，Displacement shaders实际上是在Fragment级别运行的，并且可以在表面上创建精细的细节，而不管底层几何体的顶点结构如何。因为在 Renderman 使用的原始软件渲染算法中，细粒度的表面镶嵌到大致像素大小的“微多边形”是该过程所固有的。在表面着色器执行之前，立即进行微多边形分割，并且整个过程在软件中执行，这意味着细分可以在置换后根据需要动态细化，并且Displacement 可以在添加的微多边形上重新运行。

与最初的Renderman算法相比，支持可编程OSL着色器的现代软件渲染器在几乎所有方面都更优秀、更先进，但在严格的局部光照渲染器中，它们在复制经典置换着色器的灵活性和质量方面仍然存在相当大的问题。

回到“过去”（请注意，我刻意没有使用“美好的旧时光”这个说法），RSL置换着色器可以被利用和滥用，以从简单的基础形状创建复杂的形状。从技术上来说，使用OSL仍然可以做到这一点，但它已不再是最佳选择，因为全局光照渲染器需要在渲染过程早期就知道物体的边界。这至少需要以一种近似的方式，对所有物体的所有Displacement进行早期处理。在现代软件着色框架中创建Displacement着色器时，明智的做法是将Displace限制在对大致正确的几何形状进行小规模修改，而不是，比如说，将球体变形为香蕉。在软件渲染中，大规模变形最好在渲染之前预先完成，而不是在渲染过程中进行。执行极端变形的RSL着色器曾是一种有趣且有用的工具，你仍然可以在互联网上找到此类令人印象深刻的着色器示例，但回想起来，它们容易被滥用，并且过于依赖渲染算法。 


## CPU画个圆
程序纹理通常与视觉上复杂、“繁杂”的图案相关联，这些图案具有明显的随机性。我们将在第8章及后续章节中探讨这些图案，但让我们先从简单的开始。
作为一个说明性的例子，让我们考虑一下，如果我们以顺序方式思考并在图像中设置单个像素，我们将如何绘制一个圆。用于此目的的合适数学方法是圆的参数方程：
$$
\left\{\begin{array}{l} x=x_{0}+R \cos \phi \\ y=y_{0}+R \sin \phi \end{array}\right.
$$
在这个方程中，$(x_{0}, y_{0})$ 是圆心，R 是圆的半径，而角度 ϕ 将是绘制时的自由参数。在 0 到 $2 \pi$ 之间改变 ϕ 可以画出一个完整的圆。要绘制这个圆，我们可以编写如下程序：
![2504281718 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/04/28/1mg/2504281718-.png)

现在，这个算法存在几个问题。首先，它用一系列短线段来近似一个圆，这就需要决定角度ϕ的步长要多小才能得到足够好的近似。在任何给定情况下，“足够好”究竟意味着什么甚至都不明确。其次，该算法在循环的每次迭代中都需要对两个三角函数进行大量计算。第三，如果所需的线条粗细不是一个像素，通常需要在屏幕空间中指定。第四，如果需要抗锯齿（如今这通常是绝对必要的），要在顺序线段绘制算法中正确实现并非易事。最后，第五，如果我们想用某种颜色填充圆形，这将是另一个不同的额外问题。

还有其他绘制圆形的算法，有些不需要用线段进行近似，有些甚至只需要整数加减法（相当令人惊讶），无需任何其他数学运算，但仍然存在一些基本问题：绘制过程明显是顺序进行的，而且是在屏幕空间中通过逐个设置像素来完成，这种方式不容易绘制更粗的线条、进行抗锯齿处理或填充圆形内部。当然，所有这些问题在经典计算机图形学中都已得到解决，但过程式方法实际上可以让解决这些问题变得容易得多。


## GPU画个圆

一个用于指定圆形的着色器函数不会使用参数形式，而是使用隐式方程：
$$
\left(x-x_{0}\right)^{2}+\left(y-y_{0}\right)^{2}=R^{2}
$$
这指定了圆周边上点的一个条件。在数字像素图像中，坐标恰好位于该圆周上的像素数量通常为零，因此我们先指定落在圆周内部的像素的条件，改为渲染一个实心圆：
$$
\left(x - x_{0}\right)^{2} + \left(y - y_{0}\right)^{2} \leq R^{2}
$$
实际上，这就是我们圆形着色器的全部内容。在一个简单的GLSL实现中，代码看起来大概是这样的：

![2504281851 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/04/28/1mg/2504281851-.png)

向量 P 是要着色的点，p0 是圆的中点，R 是圆的半径。圆内点的返回值为 1.0，圆外的点的返回值为 0.0。

对于图像中的每个像素都去计算一个方程，仅仅是为了给其中一些像素上色，这可能看起来很浪费，但请记住，着色器通常是用来绘制图案的。通常，表面上的每个像素都应该有某种颜色，我们只是需要决定用哪种颜色。我们是用同一个着色器同时 “绘制” 背景和前景。不是先将所有像素设置为背景颜色，然后再考虑 “我们把圆放在哪里？”，而是反其道而行之，思考 “这个点是圆的一部分还是背景的一部分？”。 

请花些时间仔细理解上面这段话。如果没有完全理解，可以再读一遍。掌握这种从里到外创建图案的方式，是程序纹理这一概念的核心。这可能看起来既笨拙又迂回，有时确实如此，但着色器就是这样工作的。

### 糟糕的代码和愚蠢的编译器
上面的代码很“naive”，意思是它不好。这是有意为之，因为明确指出它为什么不好以及如何改进，具有教学意义。它在几个方面存在问题，有些还很不明显。

首先，对向量p和p0的各个分量进行摆弄并取平方根，仅仅是在计算两点之间的距离，而在GLSL中有内置的向量数学运算和为此设计的内置函数。我们应该使用它们，因为这样更有可能以高效的方式进行编译和执行。这也会使代码更具可读性。

对于着色器编译器来说，找到这种模式并将其映射到合适的内置函数`length`或`distance`似乎是一项相当简单的任务，但请记住，着色器编译器在优化代码方面远不如常规编程语言的编译器高效。着色器需要快速编译，通常是在使用它们的应用程序执行过程中即时编译，而且着色器编译器有时会选择简单的方法，生成低效的代码。

在优化编译器变得擅长其工作（其实这也并非很久以前的事，我们说的是21世纪初）之前，编译器常常需要“手把手”地提供具有硬件友好型结构的高级代码，有时这些代码几乎看起来像汇编代码。在某些情况下，实际汇编代码片段甚至可能是最佳选择。如今，这些情况在很大程度上已成为过去，因为人类程序员通常无法找出所有能用机器代码实现的巧妙技巧，来加速代码、充分利用现代CPU的所有功能并避免执行过程中的停顿。然而，对于着色器编译器而言，一定程度的“手把手”指导仍然有用，并且对着色器的执行速度会产生很大影响。 

### 优化
让我们重写代码，使用向量数学和一个内置函数：
```glsl
// Determine whether p is inside a circle with radius R and midpoint p0 
float circle( vec2 p, vec2 p0, float R ) {
	float r = distance( p0, p ); // or length( p – p0 )
	if( r <= R ) return 1.0; // inside the circle
			else return 0.0; // outside the circle
}
```

这至少有可能是更快的代码，而且它的可读性要强得多，这不仅仅是因为注释。着色器程序员以编写难以读懂的代码而闻名，但其实并不一定非得如此。注释是允许的，而且应该使用，并且大多数其他关于如何为任何其他编程语言编写可读且可维护代码的建议，同样完全适用于着色器编程：给代码添加注释，使用具有合理描述性的变量名，给代码添加注释，将长表达式拆分成可读的部分，坚持一种普遍接受的编码风格，还有给代码添加注释。（我们是不是说过“给代码添加注释”？好吧。）你可以自由使用中间变量和命名常量，因为这些肯定会被优化掉。着色器编译器并非蠢笨至极。 


### 追求极致
如果我们想让这个着色器发挥出绝对的最佳性能，可以考虑重写它，通过在比较中使用半径的平方来避免计算平方根（这在函数 `length` 和 `distance` 中是隐含的）：
```
float circle( vec2 p, vec2 p0, float R ) {
	vec2 v = p – p0;
	float r2 = dot( v, v ); // Compute v.x*v.x + v.y*v.y by a scalar product
	if( r2 <= R*R ) return 1.0; // Extra multiplication to save one square root
				else return 0.0;
}
```

然而，这会给我们的下一步带来一些问题，我们下一步想要绘制圆的轮廓，而不是填充其内部。除了编写那些会被大量使用和复用的库函数时，在着色器中很少有必要去寻找能节省单个时钟周期的方法。在这些情况下，为了速度确实可以牺牲一些清晰度。不过，尽量避免编写不必要的复杂代码，如果代码对于不是作者本人的读者来说不是一目了然，一定要使用注释来解释代码的功能。

在这种情况下，甚至都不确定乘法运算是否比开方运算执行得更快。计算向量的长度并执行归一化是计算机图形学中非常常见的操作，鉴于这需要进行开方运算，GPU内部通常会有流水线硬件，以实现与乘法运算差不多快的速度。当你试图加速着色器代码时，不同平台的编译器表现也可能不同。不同型号、不同制造商的GPU在底层架构层面的实现可能大相径庭，甚至对图形驱动程序（着色器编译器是其一部分）进行微小的更新，都可能会抵消掉一点速度提升，甚至使其略微变慢。 

编写着色器代码时要运用常识，但请记住，为提高速度而进行重构可能会有所帮助。着色器编译器需要快速运行，因此在执行自动优化方面，它不如普通编译器出色，普通编译器可以花更多时间来分析你的源代码


### 欲罢不能的 STEP 函数

这个示例中仍然存在糟糕的代码。if - else语句在大多数编程语言中很常见，大多数程序员都熟悉其结构，但在着色器程序中使用时，它有几个缺点。

这条特定的语句在两个分支中执行相同的操作：返回一个值。在硬件层面，这对应于一种非常高效的 “选择” 指令，即通过一个逻辑条件（真或假）从两个值中选择一个。（顺便说一句，这是最初的ARB着色器汇编语言中唯一的条件指令。）然而，`if` 语句并非必须这样做。编写在两个分支中执行完全不同操作的代码也是完全合法的，并且编译器可能会也可能不会识别出这实际上是一个简单的条件赋值。

在C语言和C++ 以及它们的许多衍生语言中，有一种声名狼藉的 “三元运算符”，它恰恰可以在两个值之间执行这种条件选择。以下两段代码片段产生的结果完全相同，并且在C语言和GLSL中都是有效的代码：

![2504283921 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/04/28/1mg/2504283921-.png)

右边的代码更紧凑，同时它对人类的可读性也较差，除非该人类非常习惯于阅读这种代码。但是，更紧凑的语句的结构是不同的，并且对硬件更友好，因为它明确地告诉编译器，我们是在给一个变量赋两个值中的一个，而不是在两个完全不同、可能很长的语句序列之间进行条件选择。
着色器经常需要执行这类条件赋值操作，这就是为什么GLSL有三元运算符。然而，出于下文 “抗锯齿” 一节以及下一章中将会阐明的原因，在决定使用何种颜色时，更推荐的 “if-else” 判断方式是使用一个内置函数：step。其定义及其函数图像如下：

![2504285026 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/04/28/1mg/2504285026-.png)

这个函数返回固定值0.0和1.0，作为两个值数值比较的结果，它很可能在GPU中进行硬件加速，并且执行速度至少与普通的三元运算符或if - else语句一样快。

现在，我们可以使用`step`重写圆形着色器函数：
```
float circle(vec2 p, vec2 p0, float R) {
	float d = distance(p0, p);
	return 1.0 - step(R, d); // equivalent to (d < R) ? 1.0 : 0.0;
}
```

请注意，我们需要从1.0中减去返回值，以便将其从圆外为1.0翻转成圆内为1.0。这种翻转在着色器编程中是一种非常常见的代码模式。另一种实现方式是颠倒两个参数的顺序并写成$step (d, R)$ ，但这不是个好主意，不仅因为它令人困惑且破坏代码可读性，还因为在下一节之后我们进行抗锯齿处理时会明白的原因。但首先，让我们修改着色器以实现我们真正想要的功能：绘制一个圆的轮廓。

### 绘制轮廓

要绘制一条线，我们需要指定一个条件，用于判断一个像素何时落在该线的两条边缘之间，并使用它来选择该像素的颜色。对于圆的轮廓，我们需要确定阴影点到圆心的距离何时在半径的一个小范围内。这需要进行两次比较，可以写成两个逻辑条件。如果我们期望的线宽为w，条件将是：
```
return ((r>=R-w / 2.0) \& \&(r<=R+w / 2.0))? 1.0: 0.0;
```
其中R和r的定义与上一节代码中的定义相同。&&运算符在GLSL中确实存在，并且这段代码可以运行，但它不是最佳结构。改用step函数，代码变为：
```
return step \left(R-w^{*} 0.5, d\right)-step\left(R+w^{*} 0.5, d\right) ;
```
如果你习惯用C或C++编写高效代码，用函数调用取代简单的比较操作可能看起来不是个好主意，但请记住，`step` 是一个内置的加速函数，而且目前在GLSL中实际上并没有函数调用这回事——所有内容都由编译器内联展开，函数只是一种组织代码的方式。即使实际的函数调用是一种选择，`step` 函数总共也只映射到少数几个硬件指令，并且通常无论如何都会被内联展开。 

请注意，我们还将除以2.0改为乘以0.5。从数学角度来说，它们完全相同，但除法运算的计算成本比乘法运算要高得多。现在，编译器几乎肯定会识别出这种明显的常数除法，并将其替换为与该常数预先计算出的倒数相乘，实际上是帮我们完成了这项工作，但即使在源代码中避免使用除法也没有坏处。不管怎样，由于数字的内部浮点表示方式的特性，对任何2的常数次幂进行缩放，都将映射为指数上的简单且非常快速的加法或减法，而这整段话可能只是一个在糟糕编译器环境下成长起来的老人的唠叨。但话虽如此。对于一般变量a和b，在大多数现有的计算机架构中，计算a / b所花费的时间比a * b要长得多，而且典型的单指令多数据（SIMD）内核中执行除法的单元比执行乘法的单元要少。这可能会产生影响。 

我们的线宽w不是以设备像素来指定的，而是在着色器的坐标空间中指定。在大多数情况下，这正是我们所需要的。任何逼真的表面图案都需要在线宽在物体空间而不是屏幕空间中指定。当然，如果我们确实想在屏幕空间中指定线宽，完全可以采用以像素为单位指定的宽度，将其转换到Object空间，然后在着色器中使用。着色比顺序像素绘制要灵活得多。

### 抗锯齿
我们目前仍然只是在想要绘制的区域内绘制一种二元图案，即“开”或“关”。现代计算机图形学早已超越了这一阶段。长期以来，我们已经能够在显示设备上看到灰度层次，甚至简单的线条画也应利用这一点来更好地渲染边缘。仅用前景色和背景色这两种颜色绘制斜线和曲线轮廓时出现的锯齿状边缘很难看，而且是可以避免的。这些“锯齿”是点采样固有的副作用，在点采样中，我们只查看像素的中心，并以此来决定整个像素区域内绘制何种颜色。这里我们不深入探讨原因，但如果你学过信号处理，可能会有所了解，“锯齿”在形式上被称为aliasing，而消除锯齿或至少使其不那么明显的过程则称为anti-aliasing.

第6章主要讲抗锯齿。它不仅会介绍如何消除锯齿边缘，还会解释什么是锯齿现象以及为什么它被称为“锯齿”。不过我们至少先在这里引入这个话题，因为锯齿现象在现代计算机图形学中确实不应存在。二十年前，带有锯齿边缘的图形还可以接受，在计算机图形学早期，锯齿是常态，但如今已非如此。程序生成的图案也不能例外，需要与时俱进。 

在3D计算机图形的传统应用中，抗锯齿是渲染器的任务，而且通常工作量颇大。然而，着色器是一种函数，可通过编程让其根据渲染分辨率和观看距离改变行为。这意味着程序纹理图案可以自行进行抗锯齿处理，从而大大减轻渲染器的工作负担。 

现在是时候揭示为什么我们不辞辛劳地使用阶跃函数来绘制圆形了：通过用从0.0到1.0的渐变坡度取代生硬的阶梯，我们可以轻松地将严重走样的圆形着色器转换为一个美观的抗锯齿版本。我们将用来代替`step`的函数称为`smoothstep`：

![2504285659 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/04/28/1mg/2504285659-.png)

我们的着色器不需要做太多改变来执行实心圆的抗锯齿。我们可以用 smoothstep 替换 step：

![2504285854 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/04/28/1mg/2504285854-.png)

当然，决定平滑渐变区域宽度的w值需要仔细考量，我们在上文省略了这一细节。为了使平滑过渡区域宽为一个像素，我们希望w能让d向两侧各迈出大约一个设备像素一半大小的步长，但我们需要在着色器坐标中指定该距离。着色器空间与设备空间之间的转换在渲染时是已知的，这可以用来显式计算出合适的步长宽度。然而，通常并不采用这种方式。着色语言具有内置机制来隐式计算步长宽度，这使得计算变得容易得多。

在OSL中，通过使用内置函数 `aastep(p(a, x))` 可以非常方便地对 `step( a, x )` 进行抗锯齿处理，这意味着你只需将每次对 `step` 的调用替换为对 `aastep` 的调用即可：
```glsl
// Anti-aliasing of an edge in OSL
float aacircle( vec2 p, vec2 p0, float R ) {
	float d = distance( p0, p );
	return 1.0 – aastep( d, R );
}

```

这就是为什么在着色器中使用step函数来创建清晰边缘，而不是使用条件语句，是个好主意的原因：它使执行抗锯齿变得非常容易。一个使用if-else或类似 “非此即彼” 语句来决定颜色的程序纹理图案很有可能——几乎可以肯定——会产生难看的锯齿边缘，渲染器需要大量额外工作才能消除这些锯齿，或者至少减少它们。

在GLSL和其他GPU着色语言中，我们需要编写自己的函数来实现与OSL中aastep等效的功能，但它通过一种称为自动求导的内置机制以完全相同的方式工作。自动求导的内部工作原理和正确使用方法需要花些功夫来解释。这里，我们仅介绍如何在GLSL中执行相同的抗锯齿操作。关于其工作原理和方式的解释将在第6章“抗锯齿”中给出。

```
// Anti-aliasing of an edge in GLSL
float aacircle( vec2 p, vec2 p0, float R ) {
	float d = distance( p0, p );
	float w = fwidth( d ) * 0.5; // This is explained in chapter 6
	return 1.0 - smoothstep( d - w, d + w, R );
}
```

为了结束这次略显仓促的抗锯齿方面的偏离主题内容，我们先给出在 GLSL 中实现 aastep 的代码，暂时不做详细解释：
```
// Anti-aliased step function in GLSL 
float aastep( float edge, float value ) {
	float w = fwidth( value ) * 0.5; 
	return 1.0 - smoothstep( edge - w, edge + w, value );
}
```

将系数0.5替换为0.75通常效果更好，原因我们稍后会详细解释（没错，就在第6章）。大多数在OSL中使用内置aastep的人不需要关心它的工作原理，而且在你了解其工作原理之前，你也无需羞于在GLSL中复制此函数供自己使用。

使用我们的新工具两次，我们还可以创建平滑、纤细的轮廓。

![2504280251 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/04/28/1mg/2504280251-.png)
