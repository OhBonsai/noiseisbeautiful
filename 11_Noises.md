柏林（Perlin）最初提出的梯度噪声非常有用。考虑到它诞生的时间之久，以及1985年时计算机图形学还相当简陋的状况，它在很多方面的出色表现着实令人惊叹。然而，正如肯·柏林（Ken Perlin）本人所指出的那样，事后看来，它存在一些不尽如人意的特性。多年来，人们提出了几种更好的噪声版本来修正这些缺陷。上一章介绍的柏林最初的梯度噪声函数仍然有用，而且也仍在被大量使用，不过如今有了一些改进的变体，应该优先使用它们，因为这些变体解决了该函数的一些根本性问题。

## 特性与缺陷
多年来，许多作者从噪声的众多应用经验中总结指出，一个理想的噪声函数应具备以下特性：
- 它应该是带限的，但带宽不能太窄。一个倍频程的频率范围对于创建看起来随机的图案效果很好。
- 当它被旋转或平移时，其统计特性应该保持不变。这意味着它不应有明显可见的方向性瑕疵，或者不应有能暴露其 “虚假” 本质的底层网格痕迹。
- 如果平移量远大于其最低频率的波长，那么它与自身平移后的副本应该是不相关的。
- 它应该在任何地方都是连续且平滑的。从数学术语来讲，它应该是连续可微的。

当然，这些要求必须与仅用少量计算来计算该函数的需求相权衡，而梯度噪声已被证明是一个不错的折衷方案。然而，最初的柏林噪声算法存在缺陷，而且其中许多缺陷可以在不使函数变得复杂得多的情况下得到解决。一些改进措施甚至使函数变得更简单了。

## 折痕
相邻梯度之间的插值方式会导致噪声的二阶导数出现不连续性。这可能看起来不是什么大问题，但实际上，如果你观察噪声的单个低频分量，肉眼是可以看到这种不连续性的。当噪声被用于使表面产生位移或创建凹凸贴图时，其导数决定了强度，这时这些不连续性会清晰地表现为沿着网格单元边界的折痕。
![2505050558 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/05/1mg/2505050558-.png)
*Second order discontinuities in classic 2-D noise. Left: problem. Right: solution.*

解决这个问题的方法是在插值时使用一条在端点处更平滑的 “混合曲线”。平滑过渡函数（smoothstep）所使用的三次曲线$3t^2 - 2t^3$在其端点处斜率为零，但它的二阶导数不为零。我们可以构造一个多项式$f(t)$，使其在两个端点处的斜率和二阶导数都为零。

约束条件如下：
$f(0)=0$，$f(1)=1$，$f'(0)=0$，$f'(1)=0$，$f''(0)=0$，$f''(1)=0$

将这些约束条件应用于一个具有六个系数的一般五次多项式$At^5 + Bt^4 + Ct^3 + Dt^2 + Et + F$，计算其一阶导数和二阶导数，然后求解一个包含六个未知数的方程组，我们得到如下解：
$f(t)=6t^5 - 15t^4 + 10t^3 = ((6t - 15)t + 10)t^3$

肯·柏林（Ken Perlin）早在2002年就提出了这种改进的插值方法
“Improving Noise”, https://doi.org/10.1145/566654.566636] ，并且它已被纳入到大多数柏林噪声的商业实现中。计算这个五次多项式稍微多一些工作量（需要五次乘法运算，而不是三次），但计算插值权重只是该算法中很小的一部分。

考虑到这一单一改变带来的明显视觉效果提升，没有理由不使用它，除非在极少数情况下，你可能想要保留某个依赖于早期噪声实现细节的旧着色器的确切外观。（最好避免出现如此强烈的依赖关系。）

###  过零点与缩放瑕疵 Zero crossings and scaling artifacts

对于梯度噪声，从信号处理中借一个术语来说，在整数坐标处强制设定的过零点使得函数“锁相”了。当把几个经过缩放的噪声版本叠加在一起时，你需要小心避免出现相关性瑕疵。要考虑不要为每个倍频程都精确地缩放 2.0 倍，这样就不会导致某些点上所有项的贡献都只是零。你还应该给每一项都添加一个平移量，以避免出现噪声图案完全相同只是经过了缩放的副本在原点处叠加的情况。如果能承受额外的计算量，将每一项旋转一下也无妨。你甚至可以考虑在计算某些项之前，通过向纹理坐标添加噪声来在一定程度上扭曲网格。如果以一种相当巧妙的方式来做这件事，这会使过零点偏离规则的网格，同时又不会显著改变噪声的频谱特性。不过，平移是最重要的，而且也最容易做到。平移量具体是多少关系不大，只要它们是合理的、不同的非整数值，并且与缩放无关，还能使各项之间的噪声图案有所不同就行。如果你围绕一个公共点来缩放各项，并且这个点在视野范围内，就会出现瑕疵，下面图像就展示了这一点。

这些补救措施只是对噪声算法固有问题的一种解决办法——权宜之计。人们还提出了一些更根本的解决方案，比如在合成过程中使用不规则网格。多年来提出的大多数替代算法并没有被广泛使用，因为对于大多数用途来说，规则网格上的梯度噪声速度快且足够好用。然而，随着图形处理器（GPU）性能的不断提升，现在有可能更多地关注质量而非速度。有相当多的算法正等待着进入主流应用领域。坦率地说，梯度噪声在一定程度上是一种取巧的方法。诚然，计算机图形学本身就充满了各种取巧手段，并且希望这些手段不会被察觉，但如果你有需要，了解到还有更好的取巧方法也是不错的。其中两种方法，即加博尔噪声（Gabor noise）和稀疏卷积噪声（sparse convolution noise），将在第 13 章中简要介绍。 

![2505052521 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/05/1mg/2505052521-.png)
*Left: “Zoom” artifacts at the origin (center) from adding scaled but otherwise
identical copies of noise. Right: Translation of each term removes the artifacts.*

### Anisotropy 各向异性

当观察单个噪声实例时，方形网格会在最终的噪声图案中产生各向异性。网格并非清晰可见，但你能辨别出(x, y)主轴的方向。我们希望网格更加均匀，肉眼更难察觉。在这两方面，六边形网格更合适。 

在给出这个问题的解决方案之前，我们先来描述另外两个可以用同样方法解决的问题：单纯形噪声。

###  复杂性和单纯形网格
经典柏林噪声的网格单元是正方形、立方体或超立方体，并且需要评估的相邻单元数量以2的指数形式增长。 一维噪声需要两个相邻值，二维需要四个，三维需要八个，四维需要十六个。每增加一个维度，复杂度就会翻倍。这使得计算四维甚至三维噪声的成本相当高。

存在一些平铺方式，其中的单元格角数较少。在N维空间中平铺时角数最少的形状被称为N维单纯形。对于一维空间，它仍然是一条线，但对于二维空间，它是三角形而不是正方形。等边三角形可以平铺二维平面，并且六边形平铺（或 “交错矩形” 平铺）的中心点可以连接起来，在二维空间中形成一个三角形单纯形网格。

![2505052916 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/05/1mg/2505052916-.png)
*Simplex tiling of equilateral triangles in 2-D.*

在三维空间中，单纯形是包含一定体积且顶点数量最少的多面体：即四面体，它有4个顶点。正四面体无法铺满三维空间，但边长略有不同的四面体可以。回顾第5章中的六边形平铺，我们可以将二维三角形平铺的顶点看作是两个交错的矩形网格。三维空间中四面体的单纯形平铺可以绘制在两个交错的立方网格（三维网格，每个网格间距为1.0，且在三个维度上彼此偏移0.5）上。这在二维静态图像中很难直观呈现，但无论如何，这里尝试展示一下： 

![2505052951 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/05/1mg/2505052951-.png)
*Simplex tiling of tetrahedra in 3-D. For explanation, see the text.*

在这张图像中，两个立方网格分别由蓝色圆圈和白色圆圈表示，它们相互错开半个网格间距。每个四面体的顶点分别来自两个网格中的各两个（顶部中心的灰色形状）。为了无间隙地铺满三维空间，我们需要以不同的旋转方式使用四面体单元。构建这种铺砌方式的一种方法是首先用四个四面体组成八面体。然后，这些八面体的三种不同朝向可用于铺满三维空间（左侧的黄色、红色、绿色形状）。

另一种构建铺砌方式不太容易看出来，但却更有用，即把六个沿着连接两个网格中任意一点的对角线之一且共边的四面体组合在一起（右侧的蓝色形状）。它们组合起来的形状是一个“压扁的立方体”，也就是一个所有边长都相等的平行六面体，这个形状仅通过自身平移就能整齐地铺满三维空间。（这个形状的正式名称是三方偏方面体，但很少有人知道这个名称。就连我也老是忘记。）我们很快就会用到这种替代的铺砌方式。

这些四面体并非完全一样，但顶点之间的距离至少比立方体中顶点之间的距离更加均匀。边长为1的立方体，其棱边长为1，面对角线长为$\sqrt{3}$，相对差值为1.732，而我们用于铺砌的四面体的边长分别为1和$\sqrt{\frac{3}{2}}$，相对差值仅为1.155。三维单纯形网格的间距比立方网格的间距更加均匀。

甚至无需尝试去想象它，我们可以直接说，对于四维空间也存在类似的单纯形铺砌方式，使用的是具有5个顶点的四维4-单纯形，而且对于任何更高维度也是如此，尽管随着维度升高，单纯形（没错，这就是那个不太顺口的复数形式）会变得更加不规则、更加压扁。

$N$维空间中的单纯形有$N + 1$个角。与具有$2^N$个角的规则笛卡尔网格单元相比，这是一个很大的改进。在二维空间中，我们需要考虑的角就少了一个，是3个而不是4个。在三维空间中，我们有4个相邻点,而不是8个（8个仅为原本数量的一半），对于四维空间，我们有5个相邻单元，而不是16个。如果我们要在单纯形网格中计算噪声，那么更高维度的噪声函数可以变得更加高效。 

对于二维和三维空间而言，单纯形平铺作为噪声函数的基础确实非常有用。四维单纯形网格存在一些不均匀的问题，但它依然有用。随着我们向更高维度推进，均匀性问题会逐渐变得更严重，不过可以通过使用多个交错排列的单纯形网格，或者采用不止一个单纯形单元来计算噪声的方式来解决这些问题。高于四维的噪声极少会被用到，但值得一提的是，单纯形网格并非在所有情况下都优于笛卡尔网格。在更高维度中，确定哪些顶点构成了包含某个特定点的单纯形也会变得越来越困难，而对于笛卡尔网格单元来说，只需分别在每个维度上对坐标进行向上和向下取整，就能很轻松地列举出其网格单元的顶点。  

### 可微性

在许多情况下，不仅了解噪声函数的值，还了解其导数是很有用的。你总是可以计算多个噪声值，并用有限差分来近似导数，但这需要计算多个点的噪声值——每个维度至少需要多计算一个点。从噪声的计算方式来看，完全有可能算出解析导数，并在可用的数值精度范围内精确计算它，而且只需额外做少量的工作。所需的大部分计算都可以识别为噪声函数中的子表达式并加以复用，并且计算沿每个维度的精确偏导数，比通过对每个维度取一次有限差分来进行近似计算所做的工作要少得多。只有在你无法得知噪声函数的内部计算原理时，才需要使用有限差分法。我们正在着色器代码中实现自己的噪声函数，所以我们能够正确地做到这一点。

不幸的是，对于经典噪声而言，多项式的逐次插值最终使得最终噪声值的闭式表达式成为一个次数高得令人不太满意且带有许多混合项的多项式表达式，计算其解析导数需要进行相当多的乘法运算。这仍然比用有限差分法来近似计算的工作量要少，但也确实不太方便。罪魁祸首就是逐次插值。三维噪声是关于xyz的16次多项式，有许多混合项，而且偏导数相当复杂。


逐次插值的一种替代方法是稀疏卷积。这是一种从信号处理中借鉴来的方法，在这种方法中，采样点之间的插值被影响核的总和所取代，每个点周围都有一个影响核。在信号处理中，这也被称为脉冲求和。我们不是根据渐消曲线来混合两个值，而是将每个值乘以一个衰减函数，该函数随着与该点距离的增加而减小，然后我们只需将两个结果相加。在一维情况下，这只不过是用两个独立的因子$f_0$和$f_1$来代替$f$和$1 - f$作为插值权重。第10章（第126页）中一维噪声生成的最后一步可以这样修改： 

![2505053834 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/05/1mg/2505053834-.png)
*Left: interpolation weights. Right: impulse summation weights.*

此处选择的衰减函数虽有一定随意性，但它们都是简单的表达式，在时间 t 从 0 到 1（或相反）时从 1 平滑下降到 0，且两端斜率为零。需要注意的是，虽然显然有 $f_0 + (1 - f_0) = 1$，但权重之和 $f_0 + f_1$ 并不一定是常数。例如在 $t = 0.5$ 时，$f_0 + f_1 = 9/8$，这可能导致中间点的插值略微超过两个基值，这对严格信号重构来说是不合理的。但需注意，我们是在生成噪声而非精确重建采样信号，因此这一问题通常无关紧要。此方法的优势在于：**两个采样点无需保持固定间距即可完成混合**。例如，我们可以对采样点进行微扰动，使零点交叉（zero crossings）出现在非均匀位置。虽然插值方法也能修改以支持此特性，但脉冲叠加法（impulse summation）无需修改即可自然实现。

在一维情况下，此方法优势并不明显——即使使用计算简单但略微不完美的衰减函数 $(1 - t^2)^2$，计算两个独立衰减曲线 $f_0$ 和 $f_1$ 的工作量略高于传统的 $f$ 和 $1 - f$。新的混合方式在平滑性、可理解性上也无显著优势。但在 **二维及更高维度** 中，其价值开始显现：衰减可设计为各向同性（圆形对称），且允许任意数量的核（kernel）影响每个点。特别地，我们可以使用更少顶点的单纯形网格（simplex grid），通过单纯形顶点的核影响力合理覆盖 N 维空间。这自然引出了 Ken Perlin 后来的突破性思想：**单纯形噪声（simplex noise）**。

## 2-D simplex noise 二维简单噪声

> 译者注： 也可以看看我的推导啊，
> 1. [随机函数与白噪声](https://mp.weixin.qq.com/s/8EQeyRSzqCM6KQofdPlF-g)
2. [值噪声 ValueNoise](https://mp.weixin.qq.com/s/b1Dt5MtMtAdpaDEGGmYF9w)
3. [柏林噪声 Gradient Noise](https://mp.weixin.qq.com/s/vs9NZQxJVk8BzKGIvFJrhw)
4. [多维柏林噪声](https://mp.weixin.qq.com/s/dFLzdPxrznL2Il4g15o1iQ)
5. [柏林噪声优化 Simplex Noise](https://mp.weixin.qq.com/s/WgL6y4qYZhPcpmlJaGG3_Q)
6. [Cell Noise](https://mp.weixin.qq.com/s/NL1XL6XTEp_uOOkzBo80Ng)
7. [SmoothVoronoi 与VoroNoise](https://mp.weixin.qq.com/s/8aPTBZgNrlz1rHxCxrTIYw)
8. [Simplex Noise变种PsrdNoise](https://mp.weixin.qq.com/s/AclOzVMz_BZNgU-4idS9og)
9. [PsrdNoise 应用 FlowNoise](https://mp.weixin.qq.com/s/-bAiB4FKdm4nuoePFjjOxg) 
10. [CurlNoise 与 Streamline Shaders](https://mp.weixin.qq.com/s/QkAtzPq2ssuaAb0S_ZC8Hw)
11. [CurlNoise调节与边界](https://mp.weixin.qq.com/s/e_MKaaK0vRlkYePz5bUvLg)


单纯形噪声是肯·柏林（Ken Perlin）的一项发明，但却无法找到关于它的正式公开出版物来引用。它在2001年的计算机图形图像特别兴趣小组（Siggraph）会议上，作为硬件着色课程笔记的一部分被非正式地介绍，但它并非正式会议论文集的一部分，也从未经过同行评审。（截至2024年）仍然可以在课程组织者马克·奥拉诺（Marc Olano）所在大学的网址上找到相关描述[https://www.csee.umbc.edu/~olano/s2002c36/ch02.pdf]，但这并非科学意义上的“已发表”内容，而且该描述也不像人们期望的那样清晰。单纯形噪声曾获得专利，理想情况下这本应是一种正式的公开披露方式，但专利文件故意写得晦涩难懂，以掩盖一个事实，即这项获得专利的发明不过是由通用计算机程序实现的一种数学算法，而根据美国专利局的指导方针，这两者本身都不具备可专利性。几十年来，专利律师们通常都能绕过这一规定，而软件领域的专利情况也是一团糟。单纯形噪声的专利最终落到了一家所谓的“专利持有公司”（更准确的说法是“专利流氓”）手中，这导致人们不敢使用它。这与专利原本应有的作用完全背道而驰。不过，在2022年该专利终于到期了，如今再实现或使用它就不再有任何潜在的法律问题了。

单纯形噪声是个很棒的想法——只是其呈现方式使得那些原本可能会去实现它的人望而却步。为了绕过专利问题，有人创建了一个名为“开源单纯形噪声（OpenSimplex noise）”的无负担版本，但它运行速度较慢，而且从未流行起来。

事后看来，这项专利很可能从一开始就不具备有效性，而且也无法经受住法庭上的质疑——这倒不是因为它是一项关于软件和数学的专利（这样的专利有数十万项，而且世界各地的专利局仍在不断授予此类专利），而是因为其主要主张明显是错误的。专利所宣称的主题是“一种生成图像的方法……生成具有纹理且不存在可见网格瑕疵的图像”（原文如此）。单纯形噪声实际上存在明显可见的网格瑕疵，只是不像经典噪声那么令人难以接受，而且其坐标系经过了倾斜，偏离了轴对齐的方式，以便更好地隐藏这些瑕疵。

不管怎样，围绕单纯形噪声的专利闹剧如今已成为历史，我们可以毫无保留地介绍其算法了。它是一种使用上述工具的梯度噪声：采用单纯形网格而非笛卡尔网格，使用脉冲求和而非插值。柏林最初的版本（以及相关专利）只涵盖了三维噪声，而且那个所谓的标准参考实现的编程方式非常难以读懂，甚至还存在一个漏洞。因此，我们在这里实际上并不是在介绍他的算法，只是采用了相同的总体思路。

二维单纯形网格是由三角形构成的一种铺砌方式。我们在每个网格点周围指定一个圆形的影响区域，该区域尽可能多地覆盖相邻的三角形，同时又不会扩展到更远的单纯形单元中。

![2505054832 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/05/1mg/2505054832-.png)
*Kernels for 2-D simplex noise (red circles). Most of the area of one simplex (blue
shade) is influenced by three kernels. For clarity, only a few kernels are shown.*

这些内核（每个圆内的“波动”部分）由两部分组成：一部分是类似于经典噪声的梯度外推，另一部分是一个圆形对称的衰减函数。假设从单纯形角点$i$到正在计算的点的向量为$\vec{v}_i$，相关的伪随机梯度为$\vec{g}_i$，并且该网格是由边长为$1$的等边三角形组成的，那么我们有： 

对于每个角点$i \in \{0, 1, 2\}$：
$r^2 = \|\vec{v}_i\|^2 = \vec{v}_i \cdot \vec{v}_i$ （到网格点的距离的平方）
$w = \max(0.75 - r^2, 0)$ （径向衰减，在三角形对边处降为$0$）
$n_i = w^4 (\vec{g}_i \cdot \vec{v}_i)$ （更平滑的径向衰减乘以线性渐变）
$\text{noise} = \sum n_i = n_0 + n_1 + n_2$ （最终值就是各贡献值之和）

衰减函数$w^4$在中心$r = 0$处以及在$r = \frac{\sqrt{3}}{2}$处降为$0$时，其一阶导数和二阶导数均为$0$。它的计算也很简单：$w^4 = (w^2)^2$，只需要两次乘法运算。

梯度噪声的所有变体（单纯形噪声是其中之一），当梯度具有单位长度但方向是伪随机的时候，看起来效果很好，并且具有良好的带限特性。这不是唯一的选择，但却是最常见的选择。我们可以采用一些巧妙的方式来实现，就像之前展示的经典二维噪声代码那样，不过我们也可以假设正弦函数和余弦函数是由硬件加速的，并且对于一个伪随机角度$0 \leq \phi < 2\pi$，生成一个单位向量$(\cos\phi, \sin\phi)$。 
我们跳过了算法的一部分，而这部分很重要：我们需要找到包含我们所给点的单纯形的三个角点。有几种方法可以做到这一点，但我们将介绍一种简单且易于理解的方法。

第5章中的六边形平铺具有合适类型的网格，但在那里我们只关心找到网格中最近的点。现在我们想要找到最近的三个点。最有效的方法是分两步来做。首先，我们将点从笛卡尔坐标$(x, y)$转换为斜角坐标系$(u, v)$，其中$u$与$x$平行，但$v$相对于$y$逆时针旋转了$30$度。在进行转换时，我们取巧了一下，在$y$方向上对网格进行了一点缩放，这样我们的网格点就落在了$y$方向的整数位置上。这样一来，网格会稍微有点各向异性，但转换过程会更简单，无论是对人理解还是对计算机计算来说都是如此。每个点周围的支撑内核仍然是圆对称的——它们只是在$y$方向上稍微间隔得远一些。这种情况对噪声图案的影响人眼几乎察觉不到。

一个经过修改的单纯形网格，以及用于描述它的斜角坐标$(u, v)$。

阴影区域的$(\lfloor u \rfloor, \lfloor v \rfloor) = (0, 0)$。黄色区域表示$u > v$，绿色区域表示$u < v$。

斜角坐标系可以被看作是由每个由两个三角形组成的平行六面体单元构成的平铺。坐标为$(u, v)$的点位于左下角顶点为$(u_0, v_0)=(\lfloor u \rfloor, \lfloor v \rfloor)$的单元内。该点在这个单元内的局部坐标为$(u_f, v_f)=(u - u_0, v - v_0)$。如果$u_f > v_f$，该点就在朝着$u$正方向的右三角形内；如果$u_f < v_f$，它就在朝着$v$正方向的左三角形内。

因此，在转换之后，我们可以根据$u_f$和$v_f$哪个更大，在$(u, v)$系统中把单纯形的三个角点列举为$(u_0, v_0)$、$(u_0, v_0 + 1)$、$(u_0 + 1, v_0 + 1)$ 或者$(u_0, v_0)$、$(u_0 + 1, v_0)$、$(u_0 + 1, v_0 + 1)$。我们根据从这三个角点的$(u, v)$整数坐标计算出的哈希值来生成梯度。然后我们可以将这些角点转换回$(x, y)$系统，以计算每个角点对噪声的贡献。 
![2505050711 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/05/1mg/2505050711-.png)
*A modified simplex grid, and skewed coordinates (u,v) to describe it.
The shaded region has (floor(u), floor(v))=(0 ,0). Yellow is u>v, green is u<v.*

仅仅为了找到最近的相邻点就来回进行转换，这听起来可能工作量很大，但对于我们这种稍微有些不均匀的网格而言，实际上非常简单：
$$
\begin{cases} 
u = x + \frac{y}{2} \\
v = y 
\end{cases} \space\space \begin{cases} 
x = u - \frac{v}{2} \\
y = v 
\end{cases}
$$

就这样，我们已经弄清楚了整个算法。步骤依次如下：
1) 将输入点转换到斜角空间。
2) 确定我们所在的单元。（这能得到4个角点。）
3) 确定我们所在的三角形。（这能得到3个最近的角点。）
4) 为这3个角点中的每一个生成一个伪随机梯度。
5) 将这3个角点转换回非斜角空间。
6) 计算每个角点的径向衰减。
7) 从每个角点外推梯度渐变。
8) 计算并汇总这3个角点的所有贡献值。
9) 将输出缩放到所需的值域范围。

用GLSL（OpenGL着色语言）实现的二维单纯形噪声函数相当简洁紧凑：

```
// simple simplex noise (c) Stefan Gustavson,
// version 2024-11-12, published under CC-BY-SA 4.0
// https://creativecommons.org/licenses/by-sa/4.0/
float ssnoise(vec2 p) {
    // Staggered grid, points at integer y and integer/half x
    // (Yields a slightly non-uniform triangular/hex grid.)
    vec2 uv = vec2(p.x + p.y*0.5, p.y + 0.001); // Transform to skewed space
    vec2 i0 = floor(uv); // Tells us which grid quadrilateral contains p
    vec2 f0 = fract(uv); // Tells us which of the two triangles contains p
    float cmp = step(f0.y, f0.x); // Equivalent to "(f0.y>f0.x)?1.0:0.0"
    vec2 o1 = vec2(cmp, 1.0-cmp); // o1 is the offset to the second corner
    vec2 i1 = i0 + o1, i2 = i0 + 1.0; // Grid coordinates, used for hash
    vec2 p0 = vec2(i0.x - i0.y*0.5, i0.y); // Transform back to p space
    vec2 p1 = vec2(p0.x + o1.x - o1.y*0.5, p0.y + o1.y);
    vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);
    vec2 v0 = p - p0, v1 = p - p1, v2 = p - p2; // Vectors from corners to p

    // Compute a simple hash for each of the three corners
    vec3 iu = vec3(i0.x, i1.x, i2.x); // Hash coords
    vec3 iv = vec3(i0.y, i1.y, i2.y);
    vec3 hash = mod(iu, 289.0); // Mod to avoid truncations below
    hash = mod((hash*51.0 + 2.0)*hash + iv, 289.0); // These are not great,
    hash = mod((hash*34.0 + 10.0)*hash, 289.0);    // but "good enough"

    vec3 phi = hash*0.07482; // Scale the hash (and jumble it some more)

    // Generate three gradients
    vec3 gx = cos(phi); // sin and cos are usually fast these days
    vec3 gy = sin(phi);
    vec2 g0 = vec2(gx.x, gy.x);
    vec2 g1 = vec2(gx.y, gy.y);
    vec2 g2 = vec2(gx.z, gy.z);

    // Compute the kernels of influence from each corner
    vec3 w = 0.8 - vec3(dot(v0, v0), dot(v1, v1), dot(v2, v2)); // radial decay
    w = max(w, 0.0); // Cut off the negative part
    vec3 w2 = w*w; vec3 w4 = w2*w2; // w4 is our final radial weight
    vec3 gdotv = vec3(dot(g0, v0), dot(g1, v1), dot(g2, v2)); // extrapolated ramps

    // Compute and sum up the three contributions in one go
    float n = dot(w4, gdotv);
    return 10.9*n; // Scale the noise value to span the range [1,1]
}
```


总的来说，如果不把与0.5或2.0的乘法算作实际乘法，这个实现要计算一个二维噪声值（包括生成梯度的工作），需要进行46次乘法以及3次sin和cos调用（在现代GPU中，相同角度的正弦和余弦通常可以并行计算）。这比上一章展示的经典噪声实现所需的计算量要少一些，但差距不大。少生成一个梯度并不会带来很大差别。不过，二维单纯形噪声的计算速度至少比经典噪声稍快，而且在多个方面看起来效果更好。

请注意，径向衰减的计算方式与我们之前给出的公式略有不同，这里最大值用的是0.8而不是0.75。这是因为拉伸后的网格能够容纳内核稍大一点的圆形影响区域。

讲了这么多公式和代码，是时候看看单纯形噪声实际长什么样了。需要注意的是，由于单纯形噪声与经典噪声是完全不同的算法，它的外观也有所不同，如下页的图所示。

单纯形噪声采用小圆形波动的脉冲叠加，相较于经典噪声那种蠕动状的图案，它更有一种晃晃悠悠、团块状的特点（没错，这些都是专业术语，相信我，我可是专家），而且其图案的频带限制比经典噪声更窄。在很多情况下，这其实是个优点，但在使用它创建图案时，需要考虑到外观上的差异。单纯形噪声并不能直接替代经典噪声，大多数基于经典噪声设计的图案，若要使用单纯形噪声作为类似随机的基础函数，都需要做些调整才能达到相似效果。

基于正方形网格的经典插值噪声远未过时。有时，仅从美观角度考虑，它就是更好的选择，而且它仍然是一个非常有用的函数。

![2505051404 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/05/1mg/2505051404-.png)
*左：经典二维柏林噪声。右：二维单纯形噪声。*


### 三维单纯形噪声
三维单纯形噪声的算法与二维基本相同：
1) 将输入点转换到斜角空间。
2) 确定我们所在的单元。（这会得到8个角点。） 
3) 确定我们所在的单纯形。（这会得到4个最近的角点。） 
4) 为这4个角点中的每一个生成一个伪随机梯度。 
5) 将这4个角点转换回非斜角空间。 
6) 计算每个角点的径向衰减。 
7) 从每个角点外推梯度渐变。 
8) 计算并汇总这4个角点的所有贡献值。 
9) 将输出缩放到所需的值域范围。

我们需要多考虑一个顶点，而且梯度和所有坐标都有三个分量，但扩展过程相当直观易懂。

让我们重新审视并修改之前解释三维单纯形网格的部分图示： 
![2505051457 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/05/1mg/2505051457-.png)
*Determining which simplex contains a point in 3-D. Left: skewed coordinates
(u , v ,w) and a “squashed cube” (blue shape) containing six simplices. Right:
view of those six simplices from along the diagonal x=y=z (dotted line on left).*

我们使用斜角坐标系$(u, v, w)$，通过对每个坐标进行简单的向下取整操作，快速确定我们处于由六个四面体组成的哪个集群中，然后通过比较该“挤压立方体”单元内局部坐标的大小，来确定哪个四面体包含该点。单纯形的角点是从局部原点出发，然后按照坐标值从大到小的顺序，沿每个坐标$(u, v, w)$移动一步来确定的。例如，如果$u > v > w$ ，单纯形的角点为$(u_0, v_0, w_0)$、$(u_0 + 1, v_0, w_0)$、$(u_0 + 1, v_0 + 1, w_0)$ ，最后是$(u_0 + 1, v_0 + 1, w_0 + 1)$ 。第一个和最后一个角点是同一单元中所有六个单纯形共有的，但另外两个角点需要通过比较来确定。

这两个空间之间的转换几乎和二维时一样简单：
$$
\begin{cases} 
u = y + z \\
v = x + z \\
w = x + y 
\end{cases}$ ，$\begin{cases} 
x = \frac{-u + v + w}{2} \\
y = \frac{u - v + w}{2} \\
z = \frac{u + v - w}{2}
\end{cases}
$$

为了确定我们所在的单纯形，我们将输入点$(x, y, z)$的位置转换到斜角坐标系，得到新坐标$(u, v, w)$ 。六单纯形单元的顶部和底部顶点是所有六个单纯形共有的：
$$
(u_0, v_0, w_0)=(\lfloor u \rfloor, \lfloor v \rfloor, \lfloor w \rfloor)
$$
$$
(u_3, v_3, w_3)=(u_0 + 1, v_0 + 1, w_0 + 1)
$$

为了找到另外两个顶点，我们查看输入点相对于单元原点的位置：
$$
(u_f, v_f, w_f)=(u - u_0, v - v_0, w - w_0)=(\mathrm{fract}(u), \mathrm{fract}(v), \mathrm{fract}(w))
$$

为了遍历从$(u_0, v_0, w_0)$ 到$(u_3, v_3, w_3)$ 的每个顶点，我们首先将坐标值最大的分量加$1$，得到$(u_1, v_1, w_1)$ ，然后将坐标值第二大的分量加$1$，得到$(u_2, v_2, w_2)$ 。这需要比较各分量，并相应地计算这两个增量。在不使用if - else语句的情况下，以一种适合着色器的方式来做这件事会有点复杂，但可以用step函数来实现。

一旦我们得到了所有四个顶点$(u_i, v_i, w_i)$ ，我们将它们转换回原始空间，得到$(x_i, y_i, z_i)$ ，计算向量$\vec{v}_i=(x - x_i, y - y_i, z - z_i)$ ，并为每个顶点选择伪随机梯度$\vec{g}_i$ 。

接下来计算噪声值的公式与二维情况几乎相同，只是分量数量和项数不同：
$$ 对于每个角点i \in \{0, 1, 2, 3\}$$
$$
r^2 = \|\vec{v}_i\|^2 = \vec{v}_i \cdot \vec{v}_i
$$
$$
w = \max(0.5 - r^2, 0)
$$
$$n_i = w^3 (\vec{g}_i \cdot \vec{v}_i)
$$
$$噪声值 = \sum n_i = n_0 + n_1 + n_2 + n_3$$

三维情况下的径向衰减选择为$w^3$ ，因为$w^4$ 的衰减会有点太快。$w^3$ 看起来更好，并且足以使在$r = \frac{1}{\sqrt{2}}$ 处的二阶导数为零。柏林最初的算法使用$(0.6 - r^2)^4$ ，看起来类似，但在单纯形边界处不为零。这是个缺陷。

三维中的梯度可以用不同方式选择，但如果我们想要均匀分布的单位长度向量，一个好方法是在斐波那契球面上选取点。这使我们能够将单个哈希值映射到球面上的一个伪随机点。斐波那契球面是球面上的斐波那契螺旋线，除非你知道斐波那契螺旋线是什么，否则这么说可能没什么概念。这两个概念将在下一章讨论。目前，我们只给出将整数$k$ 映射到球面上$N$ 个向量之一的公式，不做解释：
$$k \in \{0, \ldots, N - 1\}$$
$$\theta = \frac{4\pi k}{1 + \sqrt{5}}$$
$$z = \cos\phi = 1 - \frac{2(k + 1/2)}{N}$$
$$w = \sin\phi = \sqrt{1 - z^2}$$
$$x = w\cos\theta$$
$$y = w\sin\theta$$

注意，对于$x$ 和$y$ ，只显式计算了一组$\sin/\cos$ 。角度$\phi$ 是隐式的，用其等于$z$ 的余弦值来表示，并且根据对于任意$\phi$ 都有$(\sin\phi)^2 + (\cos\phi)^2 = 1$ 来计算$w = \sin\phi$ 。以这种方式生成梯度，比在二维中生成圆上的点工作量只多一点点。 

令人惊讶的是，这些点最终在球体上分布得非常均匀：
![2505052020 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/05/1mg/2505052020-.png)
*Fibonacci sphere with 289 points (only the front-facing points are shown).*

另一种有用的方法是将正方形中的点映射到八面体上的点，并对生成的向量长度进行归一化。这是McEwan 等人在2012年发表的几篇速度优化梯度噪声函数中使用的方法
https://doi.org/10.1080/2151237X.2012.649621， 这些函数在现代硬件上仍然有用且速度非常快。然而，考虑到大多数现代GPU中三角函数的速度，斐波那契球体已经足够高效，它更灵活，并且能产生更均匀的分布。


### Simplex噪声的导数

我们曾提到，单纯形噪声的导数比经典噪声的导数更容易计算。主要原因在于求导运算对加法具有分配律：和的导数等于各项导数之和。由于单纯形噪声函数是通过波动的叠加来计算的，而非重复的插值运算，所以其导数实际上很容易推导出来，并且这些导数包含了一些部分表达式，这些表达式在计算噪声值时就已经计算过，可以重复利用。我们特定版本的单纯形噪声的解析梯度如下：

$$
\begin{array}{l|l}
\text{For each term of 2-D simplex noise:} & \text{For each term of 3-D simplex noise:} \\
n_i = w^4 (\vec{g}_i \cdot \vec{v}_i) & n_i = w^3 (\vec{g}_i \cdot \vec{v}_i) \\
\nabla n_i = w^4 \vec{g}_i - 8 w^3 (\vec{g}_i \cdot \vec{v}_i) \vec{v}_i & \nabla n_i = w^3 \vec{g}_i - 6 w^2 (\vec{g}_i \cdot \vec{v}_i) \vec{v}_i
\end{array}
$$


### 高维空间切片

*（给自己的备注：这会是一张迷幻舞曲专辑的绝佳名字。）*


通过在三维空间中定义一个图案，然后让曲面与之相交，来对任意弯曲表面进行三维纹理映射。虽然在某些情况下这是一种非常便捷的方法，但它自身存在一个潜在问题。在多维信号处理领域有一个投影 - 切片定理，它详细解释了这个问题，但这需要在傅里叶域中进行推理，而我们实际上没必要深入探讨。

只要你明白，用二维切片去切割三维噪声函数时，偶尔会以近乎垂直于噪声波动梯度的角度切过波动的中心，此时这个波动就只是一个模糊的灰色斑点。图案的这部分在二维图案中会呈现为无特征区域。即便我们使用其他函数而非梯度噪声，任意方向的切片也可能会以任意角度与图案的局部梯度相交。平行于梯度进行切割会使切片中的图案对比度强烈，而垂直于梯度切割则会导致对比度较低。如果我们对四维噪声函数进行三维 “切片”，或者对二维函数进行一维切片，也会出现同样的情况。虽然这不一定会令人反感，但要记住，对高维空间中定义的带限图案进行低维切片会引入低频成分（更大的特征），即便高维信号是严格带限的。

为了清楚表明对三维噪声进行二维切片与二维噪声看起来不同，而且可能会带来一些令人讨厌的意外情况，请看下面的图片。

![2505053517 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/05/1mg/2505053517-.png)
*在固定$z$值下对三维噪声进行平面切割。从左到右：$z = 0$处的经典噪声，$z = 0.5$处的经典噪声，$z = 0$处的单纯形噪声，$z = 0.25$处的单纯形噪声*


经典的插值噪声实际上是在$z = 0.5$处的两种不同噪声图案之间进行插值，所以上面的第二幅图展示了两种不同伪随机图案的混合，看起来和第一幅图类似。结果是图案更加模糊，对比度更低，低频成分更多，并且网格瑕疵明显更强烈，因为这两种图案的过零点是完全对齐的。

单纯形噪声具有更均匀的网格，并且对切片的确切位置不太敏感，但是在$z = 0$、$z = 0.5$、$z = 1$等等位置的平面会直接切过网格点，使得波动以正方形网格的形式出现，这种规律性太强，人眼难以将其视为 “看起来随机” 的图案。每个波动的对比度会随着其生成梯度与切割平面之间的角度而变化，但这还不够。在$z = 0.25$时，平面从网格点之间穿过，看起来效果要好得多。非轴对齐的切片最终会呈现出这两种图案的混合，通常效果也不错。不过，$x$（或$y$，或$z$）几乎保持恒定的切片可能会有问题。

这些都是最坏的情况，但它们在实际中确实可能而且会发生。尽量避免对三维噪声进行轴对齐的平面切割。如果可能的话，将切片倾斜。

肯·柏林（Ken Perlin）最初对三维单纯形噪声的表述使用了一种坐标映射，这种映射使单纯形网格与$(x, y, z)$不对齐，从而避免了轴对齐平面切割的问题。它仍然存在同样的瑕疵，只是这些瑕疵出现在一些不太可能在实际中遇到的奇怪角度的平面上。

如果你想创建一个二维图案，不要忘记二维噪声。如果有一种相当简单的方法来创建二维纹理映射坐标，那么三维纹理映射并不总是最佳选择。它有可能是最佳选择，但不能保证。二维着色器函数通常计算速度更快，设计起来也更容易。

## 一种现代且灵活的噪声函数
由于在噪声函数方面没有标准的或被广泛接受的参考实现，每个应用程序都有自己版本的噪声函数。为了给你一些可以用来试验的东西，我们给出一个最近创建的、具有开放许可证可用于任何目的的函数的源代码。这个函数是psrdnoise，其中 psrd 是 “周期性单纯形旋转梯度导数（periodic simplex rotating-gradient derivative）” 的首字母缩写。（事后看来，我们本可以给它取个更好的名字。）它由Gustavson和McEwan在2022年发布 [https://jcgt.org/published/0011/01/02/] 。（是的，就是这个——我是古Gustavson。如有相关，我毫不羞愧地推广我自己经过同行评审的成果。）在这种情况下详细描述该算法会过于冗长。如果你想要完整的解释，非常欢迎你阅读关于它的原始文章。它发表在《Journal of Computer Graphics Techniques，JCGT》是一本开放获取的出版物，它实际上并不比这本书更高级，只是更详细而已。 

现在，$psrdnoise$ 并不能解决你所有的问题，但这个函数有以下不错的特性：
- 它是新编写的，速度快，甚至与低功耗、经济型的GPU也兼容。
- 有二维和三维的变体，其中二维噪声的计算速度要快得多。
- 它是一种梯度噪声，事实证明这是在质量和速度之间的一个很好的折衷方案。
- 它使用单纯形网格来减少可见的网格瑕疵。
- 该函数只需很少的额外计算量就能计算出自身的解析梯度。
- 可以使图案具有周期性，从而在所有维度上创建具有整数周期的平铺图案。（不过，二维噪声的$y$方向周期需要是偶数。）
- 它有一个可选功能，可以旋转其生成梯度。（这一功能的用途将在第16章“动画”中详细介绍。）

函数声明如下：
```
float psrdnoise(vec2 point, vec2 period, float rotation, out vec2 gradient)
float psrdnoise(vec3 point, vec3 period, float rotation, out vec3 gradient)
```
在这里，$point$ 是二维或三维的输入点，$period$ 是一个向量，其各个维度的值表示所需的周期（对于不希望有周期性行为的维度，指定为$0.0$），$rotation$ 是我们将在第16章中介绍的梯度旋转参数，$gradient$ 是一个输出参数，返回函数在指定点处的解析梯度。

现代着色器编译器和现代GPU的单指令多数据（SIMD）执行模型使得编写一个具备各种功能的噪声函数成为可能，而且在不使用额外功能时，其运行速度仍然很快。通过删除一些额外功能的代码，这些函数的速度可以在一定程度上得到提升，但提升幅度不会很大。特别是，如果梯度的返回值从未被使用，现代着色器编译器会消除计算该梯度的“死代码”，并且当不要求周期性时，周期性坐标环绕的条件执行几乎可以毫无代价地完全跳过。这段代码是为高端GPU编写和优化的，在经济型平台上运行速度并非最优，但在目前任何一款GPU上都不会运行得极慢。

如果$psrdnoise$ 不能满足你的需求，问题可能在于该平台根本无法胜任使用程序性噪声的任务，那么你就需要使用图像纹理。也有一些功能较少、速度稍快的版本，但提升幅度也不是很大。

代码清单如下。幸运的是，这是一本电子出版物，所以你可以直接复制粘贴获取代码文本。请遵守许可条款，不要删除标明作者的头部信息。除此之外，它可完全免费用于任何用途。 

### 2维psrd noise
```
// psrdnoise (c) Stefan Gustavson and Ian McEwan,
// ver. 2021-12-02, published under the MIT license:
// https://github.com/stegu/psrdnoise/

// psrdnoise函数是二维噪声函数，用于计算噪声值和其解析梯度
// 输入：
// - vec2 x：输入的二维点坐标
// - vec2 period：每个维度的周期，若某维度值为0.0，则该维度无周期性
// - float alpha：用于相关计算（如梯度旋转等）的参数
// 输出：
// - out vec2 gradient：函数在指定点x处的解析梯度
// 返回值：噪声值
float psrdnoise(vec2 x, vec2 period, float alpha, out vec2 gradient)
{
    // 将输入的二维点x转换到一个新的坐标系uv，这里进行了坐标变换计算
    vec2 uv = vec2(x.x + x.y * 0.5, x.y);
    // 获取uv的整数部分，得到i0
    vec2 i0 = floor(uv);
    // 获取uv的小数部分，得到f0
    vec2 f0 = fract(uv);
    // 通过step函数比较f0.y和f0.x的大小，返回0或1，结果存于cmp
    float cmp = step(f0.y, f0.x);
    // 根据cmp的值创建一个二维向量o1
    vec2 o1 = vec2(cmp, 1.0 - cmp);
    // 根据i0和o1计算出另外两个点的坐标i1和i2
    vec2 i1 = i0 + o1;
    vec2 i2 = i0 + 1.0;
    // 根据i0计算出点v0的坐标
    vec2 v0 = vec2(i0.x - i0.y * 0.5, i0.y);
    // 根据v0和o1计算出点v1的坐标
    vec2 v1 = vec2(v0.x + o1.x - o1.y * 0.5, v0.y + o1.y);
    // 根据v0计算出点v2的坐标
    vec2 v2 = vec2(v0.x + 0.5, v0.y + 1.0);
    // 计算从输入点x到点v0、v1、v2的向量x0、x1、x2
    vec2 x0 = x - v0;
    vec2 x1 = x - v1;
    vec2 x2 = x - v2;

    // 定义一些中间向量，用于后续的周期性处理
    vec3 iu, iv, xw, yw;
    // 检查period向量中是否有大于0.0的分量，判断是否需要进行周期性处理
    if (any(greaterThan(period, vec2(0.0)))) {
        // 将v0、v1、v2的x分量组成向量xw
        xw = vec3(v0.x, v1.x, v2.x);
        // 将v0、v1、v2的y分量组成向量yw
        yw = vec3(v0.y, v1.y, v2.y);
        // 如果period的x分量大于0.0，则对xw的每个分量取模（模值为period.x）
        if (period.x > 0.0)
            xw = mod(vec3(v0.x, v1.x, v2.x), period.x);
        // 如果period的y分量大于0.0，则对yw的每个分量取模（模值为period.y）
        if (period.y > 0.0)
            yw = mod(vec3(v0.y, v1.y, v2.y), period.y);
        // 根据处理后的xw和yw计算iu和iv
        iu = floor(xw + 0.5 * yw + 0.5);
        iv = floor(yw + 0.5);
    }
    else {
        // 如果不需要周期性处理，直接将i0、i1、i2的x和y分量分别组成iu和iv
        iu = vec3(i0.x, i1.x, i2.x);
        iv = vec3(i0.y, i1.y, i2.y);
    }

    // 通过取模运算生成初始哈希值
    vec3 hash = mod(iu, 289.0);
    // 对哈希值进行一系列计算和取模操作，进一步处理哈希值
    hash = mod((hash * 51.0 + 2.0) * hash + iv, 289.0);
    hash = mod((hash * 34.0 + 10.0) * hash, 289.0);
    // 根据哈希值和alpha计算psi向量
    vec3 psi = hash * 0.07482 + alpha;
    // 根据psi计算gx和gy向量，分别为余弦值和正弦值组成的向量
    vec3 gx = cos(psi);
    vec3 gy = sin(psi);
    // 从gx和gy中分别取出对应分量，组成二维梯度向量g0
    vec2 g0 = vec2(gx.x, gy.x);
    // 从gx和gy中分别取出对应分量，组成二维梯度向量g1
    vec2 g1 = vec2(gx.y, gy.y);
    // 从gx和gy中分别取出对应分量，组成二维梯度向量g2
    vec2 g2 = vec2(gx.z, gy.z);

    // 计算从输入点x到各相关点的向量的点积，并据此得到w向量，用于后续的权重计算
    vec3 w = 0.8 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2));
    // 对w进行取最大值（与0.0比较）操作，确保w的值非负
    w = max(w, 0.0);
    // 计算w的平方，得到w2
    vec3 w2 = w * w;
    // 计算w2的平方，得到w4，作为最终的权重向量
    vec3 w4 = w2 * w2;
    // 计算梯度向量与对应向量的点积，得到gdotx向量
    vec3 gdotx = vec3(dot(g0, x0), dot(g1, x1), dot(g2, x2));
    // 通过点积计算出噪声值n
    float n = dot(w4, gdotx);

    // 计算w3，为w2与w的乘积
    vec3 w3 = w2 * w;
    // 计算dw，用于后续梯度计算的中间量
    vec3 dw = -8.0 * w3 * gdotx;

    // 计算dn0，是计算解析梯度的中间结果
    vec2 dn0 = w4.x * g0 + dw.x * x0;
    // 计算dn1，是计算解析梯度的中间结果
    vec2 dn1 = w4.y * g1 + dw.y * x1;
    // 计算dn2，是计算解析梯度的中间结果
    vec2 dn2 = w4.z * g2 + dw.z * x2;
    // 将dn0、dn1、dn2相加后乘以10.9，得到最终的解析梯度，并赋值给gradient
    gradient = 10.9 * (dn0 + dn1 + dn2);
    // 将噪声值n乘以10.9后返回
    return 10.9 * n;
}
```

### 3维psrd noise

```
// psrdnoise (c) Stefan Gustavson and Ian McEwan,
// ver. 2021-12-02, published under the MIT license:
// https://github.com/stegu/psrdnoise/

vec4 permute(vec4 i) {
    vec4 im = mod(i, 289.0);
    return mod(((im*34.0)+10.0)*im, 289.0);
}

float psrdnoise(vec3 x, vec3 period, float alpha, out vec3 gradient)
{
    const mat3 M = mat3(0.0, 1.0, 1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 0.0);
    const mat3 Mi = mat3(-0.5, 0.5, 0.5, 0.5,-0.5, 0.5, 0.5, 0.5,-0.5);
    vec3 uvw = M * x;
    vec3 i0 = floor(uvw), f0 = fract(uvw);
    vec3 g_ = step(f0.xyx, f0.yzz), l_ = 1.0 - g_;
    vec3 g = vec3(l_.z, g_.xy), l = vec3(l_.xy, g_.z);
    vec3 o1 = min( g, l ), o2 = max( g, l );
    vec3 i1 = i0 + o1, i2 = i0 + o2, i3 = i0 + vec3(1.0);
    vec3 v0 = Mi * i0, v1 = Mi * i1, v2 = Mi * i2, v3 = Mi * i3;
    vec3 x0 = x - v0, x1 = x - v1, x2 = x - v2, x3 = x - v3;
    if(any(greaterThan(period, vec3(0.0)))) {
        vec4 vx = vec4(v0.x, v1.x, v2.x, v3.x);
        vec4 vy = vec4(v0.y, v1.y, v2.y, v3.y);
        vec4 vz = vec4(v0.z, v1.z, v2.z, v3.z);
        if(period.x > 0.0) vx = mod(vx, period.x);
        if(period.y > 0.0) vy = mod(vy, period.y);
        if(period.z > 0.0) vz = mod(vz, period.z);
        i0 = floor(M * vec3(vx.x, vy.x, vz.x) + 0.5);
        i1 = floor(M * vec3(vx.y, vy.y, vz.y) + 0.5);
        i2 = floor(M * vec3(vx.z, vy.z, vz.z) + 0.5);
        i3 = floor(M * vec3(vx.w, vy.w, vz.w) + 0.5);
    }
    vec4 hash = permute( permute( permute(
        vec4(i0.z, i1.z, i2.z, i3.z ))
        + vec4(i0.y, i1.y, i2.y, i3.y ))
        + vec4(i0.x, i1.x, i2.x, i3.x ));
    vec4 theta = hash * 3.883222077;
    vec4 sz = hash * -0.006920415 + 0.996539792;
    vec4 psi = hash * 0.108705628;
    vec4 Ct = cos(theta), St = sin(theta);
    vec4 sz_prime = sqrt( 1.0 - sz*sz );
    vec4 gx, gy, gz;
    if(alpha != 0.0) {
        vec4 px = Ct * sz_prime, py = St * sz_prime, pz = sz;
        vec4 Sp = sin(psi), Cp = cos(psi), Ctp = St*Sp - Ct*Cp;
        vec4 qx = mix( Ctp*St, Sp, sz), qy = mix(-Ctp*Ct, Cp, sz);
        vec4 qz = -(py*Cp + px*Sp);
        vec4 Sa = vec4(sin(alpha)), Ca = vec4(cos(alpha));
        gx = Ca*px + Sa*qx; gy = Ca*py + Sa*qy; gz = Ca*pz + Sa*qz;
    }
    else {
        gx = Ct * sz_prime; gy = St * sz_prime; gz = sz;
    }
    vec3 g0 = vec3(gx.x, gy.x, gz.x), g1 = vec3(gx.y, gy.y, gz.y);
    vec3 g2 = vec3(gx.z, gy.z, gz.z), g
```

这段源代码完全没有注释，如果你追求应用程序的简洁性，这可能很有用，但代码可读性较差。带有适当注释的版本以及此处展示的精简版本，均可从Github[https://github.com/stegu/psrdnoise]下载。该代码库会持续维护，可能包含上述代码清单中没有的修复或调整。当然，也欢迎在那里发表评论、提出建议和疑问。 

## 多重分型

我们已经展示了几个类似分形布朗运动（FBM）的“伪分形和”的例子，在这些例子中，噪声或类似的带限函数以逐渐更精细的尺度相加，从而创造出一种分形的外观。为了模仿实际分形的自相似性，这些和的所有项都是相互独立的。典型的和式为：
$$
F(\vec{p}) = \sum_{i = 0}^{k} 2^{-i} \text{noise}(2^{i} \vec{p})
$$

现在，由于我们一次计算这些和中的一项，并且是按照特定的顺序进行的，所以没有什么能阻止我们尝试让细粒度的项依赖于之前较粗粒度的项。如果我们这样做，从严格意义上来说，我们就不再是在模拟分形了，但这个定义可以扩展以涵盖这种不同类型的图案。用来描述它的术语是多重分形，这意味着图案的外观仍然具有分形特征，但它并非严格自相似。当你放大观察时，某些区域的外观会与其他区域不同——可能存在根本上的差异。

具有多重分形特性的现实世界物体的一个常见例子是地形。由于大陆漂移而形成的山脉，最初或多或少是均匀的分形，到处都呈现出崎岖的外观，但随着时间的推移，山峰被侵蚀，较低的区域则被碎石和土壤填满。这就形成了一种独特的外观，锯齿状的山峰周围环绕着较为平坦和光滑的山坡和低地。我们可以通过对分形和中后面的项进行加权来模拟这种情况，并且在前面各项的和为低值的地方不添加任何细粒度的项。从数学角度来看，它可以这样表述：
$$
F_{k}(\vec{p}) = \sum_{i = 0}^{k} A_{i} \text{noise}(2^{i} \vec{p})
$$
其中，每个新项的权重$A_{i}$不仅取决于$i$，还取决于$F_{k - 1}$，即前面各项的和：$A_{i} = A(i, F_{k - 1})$ 。要创建一个看起来像地形高度图的函数，即山峰周围是平坦区域，只需简单地设置$A_{k} = F_{k - 1}$，同时要注意进行缩放以确保$F_{k} \geq 0$，这就足够了。下一页的图中展示了这样一种图案。在右侧的图像中，较暗的区域更大且更平坦，因为在第一项接近零的地方没有添加后面的项。通过使每一项的权重不仅取决于其频率，还取决于更多的参数，我们可以在不同的区域模拟出不同的伪分形维数。 

![2505055245 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/05/1mg/2505055245-.png)
*左图：仅根据频率确定权重的噪声项之和。右图：根据频率以及先前项的累积和来确定权重的噪声项之和。*

20世纪90年代的一个早期演示效果名为“湍流”，它是用乘积来代替求和：
$$
F(\vec{p}) = \prod_{i = 0}^{k} 2^{-i} \text{noise}(2^{i} \vec{p})
$$

从数学角度来讲，这让我们处于非常不稳定的境地，因为即使是后面的因数也可能对最终结果产生很大影响，而且这个乘积并不能保证收敛。通过对每一项以及最终结果进行仔细的缩放，这个老方法可以创造出一些有趣的图案，但并不推荐这样做。无论是在图案方面还是在其幅度方面，结果都很难控制，而且通过使用适当加权的和，能够以更可控的方式实现视觉上相似的结果。此外，要模拟湍流的视觉外观（这是用乘积代替求和这种技巧的最初原因），使用流噪声能更好地实现，这将在下面“扭曲”一节中介绍。

在尝试伪多重分形和时，没有什么能阻止我们尽情发挥，但最好让$A_{i}$的表达式保持相对简单，否则很难控制结果。混乱并不总是坏事，尤其是对于创造性工作而言，但对于程序性图案，我们希望的是可控的混乱，其函数参数对于程序员和艺术家（他们可能是同一个人，也可能不是）来说都要有一定意义。我们希望我们的伪分形具有实际分形的外观，但表现得更规整。 

## 扭曲
使用多重分形还能做的另一件事，是基于前面的项来扭曲后面项的坐标。这有时被称作Domain disortion，有时也叫做Warping。这两个名称都很贴切，后者虽不那么正式，但更为常用。对于噪声的多重分形和，有一件特别有意思的操作，就是依据前面各项的梯度，来移动后面各项的纹理坐标。（此时，拥有一个能自行计算解析梯度的噪声函数，当然会大有帮助。）通过这个技巧，我们能让后面的项在梯度较大的区域收缩，在梯度较小的区域伸展；或者通过翻转符号，实现相反的效果。这是Ken Perlin 和 Fabrice Neyret 在他们2001年的非正式文章《Flow Noise》[http://www-evasion.imag.fr/Publications/2001/PN01/sketch_col.pdf] 中提出的想法之一，它能创造出一些相当有趣的视觉效果. Flow Noise特别适合用于动画制作，在动画中，它无需实际进行任何流体模拟，就能营造出漩涡、湍流的效果——这也正是它得名的原因。我们将在第16章再次探讨它。

下图展示了由四个频率逐渐升高的噪声项的简短和所生成的图案，其中这些项的坐标沿着前面每一项的梯度之和进行了位移。请注意,Warping所产生的细节，比我们仅使用三个未经过Warping处理的项求和所能得到的细节要清晰得多。这张图像看起来至少有点像云朵或滚滚浓烟，而这正是湍流效果的典型例子。

![2505055823 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/05/1mg/2505055823-.png)
*“Flow noise” in the style of Perlin and Neyret. Each term in a short fake fractal
sum is displaced along the sum of the gradients of the previous terms.*

Domain distortion会导致坐标映射中局部尺度的拉伸和收缩。通过精心构建坐标位移向量，我们可以创造出不同的扭曲外观。像梯度噪声这样的平滑标量函数的梯度向量就是一个很好的起点。通过将该梯度旋转90度，我们可以创造出一种不同类型的位移效果，看起来更像是局部的漩涡，而不是收缩和伸展。将二维向量旋转90度是一个非常简单的操作，只需要翻转符号并交换分量即可：向量$(x, y)$会变换为$(-y, x)$。

具有这种旋转位移的Warping效果看起来截然不同，对于某些应用场景来说可能更为合适。这里存在许多可能的变体，有很大的实验空间。Warping是一个很有趣的工具，但使用起来也颇具难度。

![2505050026 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/05/1mg/2505050026-.png)
*“Flow noise”, but with displacements happening at a right angle to the gradient.*

流噪声使用噪声的梯度作为位移的起点，但这当然不是唯一的选择。用两个不相关的噪声值来位移$(x, y)$中的每一项，比如在相隔合理距离的两个点上计算得到的噪声值，这样会使Warping后的图案呈现出另一种样貌：

![2505050102 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/05/1mg/2505050102-.png)
*Fake fractal sum of noise with displacements from uncorrelated noise values.*

当被Wrapping的图案不是噪声时，使用噪声进行Warping无疑也是一种选择。通过Warping处理，原本重复且相当单调的图案在视觉上会变得更加令人愉悦。最常见的做法是进行相当细微的位移，以营造出一些 “晃动” 效果和不完美之处，但即便相当极端的Warping有时也能成为有用的工具。需要注意的一点是坐标反转，当位移函数的变化速度（具有更强的梯度）比纹理坐标更快时，就会发生这种情况。这会导致Warping后的坐标在局部反转方向。不过，即便如此，这种情况有时也能派上用场。
![2505050332 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/05/1mg/2505050332-.png)
*Progressively stronger noise-warping (left to right) of a checkerboard pattern.*

## 频率限制

由于梯度噪声的一个分量是带限的，每个网格单元上最高频率为一个周期，所以我们可以通过简单地舍弃对于当前分辨率来说细节过于丰富的项，来防止分形布朗运动（FBM）风格的伪分形和中高频项产生混叠现象。一种更巧妙的处理方式是在高频项被完全舍弃之前，让它们逐渐衰减。如果循环是按照从最大特征到最小特征的顺序添加项，那么当后面的项将被舍弃时，我们甚至可以提前退出循环。下面的代码就是一个这样的例子。
```
// vec2 uv 是纹理坐标，取值范围在 [0, 1] 内
float fw = length(fwidth(uv)); 
// “uv 空间中一个像素的大小”
float f = 4.0; 
float w = 0.8;
float offset = 3.14159365; 
// 任意无理数
float nsum = 0.0;
for (float i = 0.0; i < 8.0; i++) { 
// 项的最大数量为 8
    float n = noise(f * uv + offset); 
    // 偏移量可防止相关性瑕疵
    float fade = smoothstep(0.5, 0.75, f * fw); 
    // 频率限制
    if (fade == 1.0) break; 
    // 不处理任何更细粒度的项
    n = mix(n, 0.0, fade); 
    // 淡入到平均值（零）
    nsum += w * n;
    f *= 2.0; 
    w *= 0.5; 
    // 为下一个倍频程做准备
    offset *= 2.7182818; 
    // 不相关的数
}
```
通过对这种噪声模式进行阈值处理而渲染出的图像如下所示。添加的项数会根据分辨率动态、自动且按像素变化。在逐渐淡出之后，任何添加小于一个像素细节的项都会被丢弃。（很巧妙，对吧？）

![2505050606 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/05/1mg/2505050606-.png)
*Frequency clamped fake fractal sums of noise. Left: 100x100 pixels, 4 terms.
Center: 200x200 pixels, 5 terms. Right: 800x800 pixels, 7 terms.*
