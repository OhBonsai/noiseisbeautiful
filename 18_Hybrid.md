

在本书中，我们一直专注于"纯粹"的程序化着色器——更准确地说，是无状态且局部的着色函数。这意味着着色器可以依赖位置、时间、入射光角度和波长等多种参数，但不应显式依赖先前计算结果或邻近点的数值。无状态的局部着色器虽然高效便捷，但这些限制也相当严格，在许多情况下值得考虑突破这些约束。

引入时间记忆和邻近数据访问最直接的方式就是使用纹理图像。图像可以存储图案本身，也可能包含辅助数据。预计算程序化纹理当然会固定其分辨率（失去"无限缩放"的特性），但纹理分辨率仍可根据视图动态调整，因此未必是重大缺陷。

在某些情况下，将程序化方法与成熟的基于图像的方法相结合是非常明智的选择，这绝非禁忌或可耻之事。虽然无状态局部着色函数具有代码美学价值，但计算机图形学的核心在于创造足够逼真且高效的视觉效果。现代GPU具备强大的纹理处理能力，完全可以用来支持和增强程序化方法。

本章将展示纹理图像作为程序化方法补充的典型场景。与其称之为"不纯"的程序化方法，我们更愿意尊重地称其为混合式程序化方法。

## 缓慢或静态变化

对于保持静态或变化极其缓慢的复杂图案，逐帧重新计算可能非常低效。现代GPU的内存和带宽虽然有限但足够充裕，刻意闲置这些资源并非明智之举。即使渲染到纹理，程序化方法仍具优势：分辨率可根据场景、当前视图和输出设备动态调整，且生成代码远比存储纹理图像更紧凑。虽然执行时内存占用不会减少，但能节省存储空间，更重要的是降低网络传输时的带宽需求。

缓慢动画通常可通过稀疏关键帧插值实现。但要注意：基于图像的移动特征插值（而不仅是颜色变化或淡入淡出）总会产生模糊，甚至出现类似老式双重曝光的"重影"现象。视频压缩技术采用运动补偿技巧，通过扭曲前一帧来预测下一帧，该技巧同样适用于动态纹理。在视觉特效中，扭曲与插值结合称为变形。程序化内容实时编码的难点在于编码工作量远大于解码。不过鉴于我们对程序化图案未来运动轨迹的了解，至少可以实现部分运动补偿来减轻插值导致的重影和模糊。是否值得投入精力则需视具体情况而定。

## 极端缩小情况

程序化纹理在放大时表现优异，但在极端缩小（远距离观察）时的解析抗锯齿却成难题。相反，传统纹理图像因分辨率限制在放大时存在问题，但通过mipmap（预先滤波降采样生成多级纹理）能很好处理缩小情况。现代GPU通常硬件加速该过程，纹理上传时即可自动完成且几乎无性能损耗。对于程序化纹理的缩小处理，利用这一通用GPU特性是明智之选——因为用纯程序化方式表达高细节图案的低分辨率形态极其困难。当然mipmap需要先将图案渲染到纹理图像，但仍可实时完成（甚至逐帧生成）。

## 模糊、泛光与涂抹

数字媒体制作中的许多视觉效果（如均匀/距离相关的模糊、高光泛光、光晕等）都需要邻近像素信息。涂抹、污迹和颜料流淌等效应用图像处理更易实现，现代实时渲染通常需对帧缓冲进行多重后处理。

图像缓冲操作当然可结合程序化方法——局部模糊/涂抹程度可由噪声或其他程序函数控制，程序化图案也可渲染到纹理再施加模糊。某些程序化图案能直接生成带模糊效果，但模糊处理本质上需要了解局部区域（而非单点）的图案特征，这与极端缩小时的抗锯齿属于同类难题。

## 时间相关特效

某些时间相关特效（如运动模糊这类时间抗锯齿）难以用程序化方式通用实现。部分渲染框架支持分布式采样（在像素抖动采样基础上增加虚拟快门时间内的多时刻采样），但实时渲染中需放弃"顶点着色器将物体变换到固定摄像机空间位置"的基本假设。运动模糊与时间抗锯齿本质属于跨物体/着色器的屏幕空间效应，因此更适合基于图像处理（尽管片段/顶点着色器可提供重要支持）。

## 傅里叶方法

第17章提到的傅里叶合成法可生成宽波长范围的海浪（避免数十数百项叠加）。该方法的优势在于默认（实际由定义决定）具备周期性，作为纹理时无缝平铺，且FFT算法特别适合生成2的幂次方尺寸图像——这也正是GPU纹理的传统最优尺寸。

虽然多数图像无法仅用功率谱描述，但类噪声/波动图案常属例外。通过简单功率谱（程序化函数定义或低分辨率采样插值）的逆FFT可生成这类均匀图案。即便使用高分辨率采样功率谱也有价值——相位渐变创造的动画效果用其他方法难以实现。当然傅里叶合成对具有明显特征（颗粒/斑点/局部形状）的图案完全无效，但在特定领域表现卓越。




## **模拟（Simulations）**

传统上，程序化图案主要是“欺骗视觉”，即在不真正模拟其背后过程的情况下，创建某种模式的模仿。然而，随着计算机整体性能和 GPU 的不断提升，如今已经可以在实时环境中对诸如波浪、湍流等现象进行至少一些简化后的模拟。其中一些模拟可以在二维规则网格中实现，这使得它们非常适合通过迭代过程作用于纹理图像来实现。在这种情况下，图像数据可以用于表示模拟中的物理参数，如局部压力和速度。

为了生成你期望看到的波浪和湍流图案，直接的物理模拟通常需要相当高的空间分辨率，并且每帧动画往往也需要多个时间步长，因此在实时应用中仍然较为困难。不过，有许多方法可以在物理精确模拟与传统的程序化“欺骗”之间找到折中之道。

一种方法是模拟大尺度的现象，而用其他方法（例如噪声）生成更细小的细节。例如，可以模拟大尺度的波浪，但小规模的涟漪和泡沫则可以用噪声伪造；雾气或云层的位置和厚度可以基于模拟的物理属性，但其外观可以用噪声伪造；火焰燃烧的位置和强度可以被模拟，但可见的火苗则由程序化噪声生成；水花飞溅的位置和方式可以被模拟，但其外观可以非常详细地伪造出来。程序化方法在对环境做出反应和动态交互方面存在局限，而模拟本质上在这方面表现更好。

波浪和湍流从形式上看依赖于流体介质中的局部压力和速度，但在效率上，识别出这些现象的大尺度特征并在较粗的尺度上模拟它们更为高效。即使你不将问题表述为一组微分方程并进行数值求解，也可以在一定程度上考虑物理定律——至少是近似的。对于波浪模拟来说，我们观察到波浪在时间上具有持续性，我们可以存储它们的振幅、波长、方向和相位，在小尺度上短时间动画中改变相位，并使用一个相对粗糙的网格来模拟波浪的产生、传播和衰减。对于湍流效果，我们可以存储某种“涡旋度”的量作为独立参数，随着时间推移扩散和发展。这样可以在不需要过于精细的模拟网格的前提下，生成相当自然的漩涡图案。

在处理程序化几何时，像水流、体积火、烟雾和爆炸这样的动态效果可以通过一些“粘稠”粒子进行模拟。本书第二部分计划深入探讨程序化几何的相关内容，因此在这里不再赘述。甚至也不会提及所有可以在2D纹理中使用近似模拟的技巧。有很多有趣的事情你可以尝试，但它们可能不适合写进这本书中。



## **细节纹理（Detail Textures）**

在实时计算机图形学中，一个至今仍然普遍存在的问题是：纹理在近距离观看时会显得模糊。图像基础的纹理仍然是目前在计算机图形中给表面添加图案的最常用方式，但它们的分辨率有限，而在实时渲染中很难预测用户会关注哪些地方。因此，不可能为所有表面都准备足够高分辨率的纹理以应对好奇观众的近距离审视。

解决这一问题的一种方法是在靠近物体时向表面上叠加细节纹理。这些纹理可以是类似噪声的颗粒感，或者是一种仅在非常接近时才起作用的凹凸贴图。图像基础的细节纹理最好以无缝平铺的模式覆盖在模糊的、面向对象的主纹理之上。这种细节图案可以在同一类表面上共享。这种方法自1990年代多纹理和纹理混合引入GPU以来就已存在，但至今仍未广泛应用于实际生产中。

通过程序化方法生成细节纹理也许并不是使其看起来真实可信的最佳方式，但它已经足够好用了。它肯定比没有强，而且程序化细节在放大到极端程度时仍能保持清晰锐利。这也是一种更好地利用GPU未被充分利用的计算能力的方式。当运行一个着色器访问多个高分辨率纹理图像并组合它们以计算表面颜色时，通常会有大量闲置的算术单元可以加以利用。

作为程序化细节的一个具体例子，让我们回到第13章的主题，渲染一张图像，仿佛它是通过传统四色半调印刷技术印在纸上的效果。下图没有提供源代码，但标题下方有一个链接指向一个带有详尽注释源代码的在线演示。该着色器使用了几层噪声来在近距离查看时表现出良好效果，除此之外代码量并不太多。

![2506290120 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/06/29/1mg/2506290120-.png)
*一个半调着色器，尝试模拟在纸上印刷的物理效果。
实时演示及完整源码可在 https://www.shadertoy.com/view/fdjyR1 查看。*

在纹理缩小（minification）时，这个着色器会切换到使用原本用于生成半调图案的连续色调纹理图像。诚然，你需要了解半调技术是如何工作的，才能编写这样的着色器，但其基本原理其实并不难掌握。虽然在这个着色器中实现所谓的“光学网点增益”（optical dot gain）并不是那么明显，但我恰好在1990年代为我的博士论文花了很多年时间分析半调图像，所以我凭记忆就完成了这部分。我曾经非常仔细地研究过大量印刷出来的半调图像。（有趣的是，“dissertation”这个词正好是“I stare in dots”的字母异位词。）

这种极端近距离下的细节看起来或许有些夸张，但实际上并非多余。现实世界拥有极其丰富的细节，而当合成内容中缺乏这些细节时，往往会严重破坏真实感。许多游戏中，你看到的所有纸张都使用相同的通用“文件”纹理，NPC 读的每本书上的文字也都是模糊一片，毫无区别。其实不必如此。一页文字所需的描述数据量其实很小，如果需要的话，它也可以动态渲染出来。计算机非常擅长做这件事。虽然在着色器中实时渲染一整页 PDF 页面未免有些夸张，也不值得消耗计算资源，但完全可以在远低于每帧一次的频率下，以动态分辨率将页面渲染到一张纹理上。如果有足够的理由去实现，我们完全可以设想在一个虚拟环境中（比如一款游戏），玩家真的能找到一本书并坐下来阅读。更贴近游戏需求的做法则是让控制面板或公告板上的标识和标签在近距离观看时清晰锐利，而不是像素化得难以辨认。虚拟世界要看起来逼真，就需要更多细节，因为现实世界无处不在细节。




## **绘制混合（Painted Blends）**

在1990年代末期，随着硬件加速图形开始普及，GPU 开始支持多纹理（multi-texturing），这意味着在渲染一个片段时，可以在同一个渲染通道中使用多个纹理图像。如今，几乎所有应用程序都广泛使用这一特性，并且通过着色器，你可以自由地以任何方式使用来自纹理图像的采样数据。除了颜色和透明度之外，纹理还可以描述凹凸贴图、用于混合其他纹理的权重，甚至材料的物理属性，如摩擦力或弹性，以辅助基于着色器的模拟。

不同的纹理可以拥有不同的纹理坐标集，因此它们在场景中的分辨率可能会有显著差异。多纹理的一个常见用途是隐藏纹理图像固有的周期性，这可以通过组合两个具有不同缩放比例和角度的纹理来实现，或者通过使用低分辨率图像来混合两个或多个高分辨率纹理。如果处理得当，这种方法非常有效，但需要格外小心，以免在任何放大倍率下显露出纹理的重复模式。远距离视图尤其容易暴露出这种周期性，即使是在当今最精心制作的游戏中也是如此。下面展示了一个顶级质量游戏的例子，在其最终发布版本中仍然出现了明显的纹理周期性问题。（这些图片来自迄今为止最美丽的开放世界游戏之一，这是一个小问题。该游戏世界总体设计令人惊叹。这也说明了基于图像的纹理周期性仍然是一个问题。）

![2506290440 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/06/29/1mg/2506290440-.png)
Guerrilla Studios 开发的游戏《Horizon Forbidden West》截图。浅水区的焦散纹理在时间和空间上都是周期性的，与其他内容相比显得异常人工化。  

![2506290424 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/06/29/1mg/2506290424-.png)
*在近距离视角下，焦散动画的相位被局部偏移以减少周期性视觉效果，但它依然存在。现在片段使用的是动画中的不同帧，因此需要一个3D图像基础的纹理。这类纹理体积相当大。*

对于纹理来说，绘制混合权重通常是更合适的选择，例如在游戏中对地形进行纹理处理。虽然游戏环境需要精心设计，但这种设计通常发生在更大的尺度上。例如，一条路径穿过地形的位置通常是手工绘制在地形数据中的，但路径上和路径外地面的细节外观仍可以部分或全部使用程序化纹理。混合权重和细节也可以反过来混合：一种非周期性的程序化混合方法可用于掩盖混合成分中图像基础纹理的周期性。至少考虑将某些复杂的多纹理着色器的部分组件用程序化方法实现，是非常有用的。



## **对图像数据的程序化操作**

多纹理方法包括一些对参与图像的“狂野”混编。对图像的操作可以让原始图案在结果中几乎无法辨认。这个领域的一些关键词包括**分层纹理**（layered textures）、**滚动纹理**（scrolling textures）和**扭曲映射**（warp maps）。任天堂对这些方法的经典应用有一个很好的概述视频，链接为 [https://www.youtube.com/watch?v=8rCRsOLiO7k](https://www.youtube.com/watch?v=8rCRsOLiO7k)。当然，这些方法的任何部分都可以使用程序化图案作为其组成部分。

纹理图像并不一定代表 RGBA 颜色。有充分的理由考虑使用图像来表示有助于生成程序化图案的数据。这些数据可以是一个 2D 或 3D 的矢量场，或者其他影响程序化图案计算的参数。特别值得关注的是第7章中介绍的**带符号的距离场**（Signed Distance Field, SDF）。它们可以是程序化的，但也非常适合采样并存储为纹理图像。除了沿着“骨架线”（即到轮廓上两个或多个点的距离相同的地方）以外，带符号的距离场具有单位长度的梯度，其方向连续变化，而且大部分情况下变化缓慢。

作为纹理图像存储的距离场可以表示任意复杂形状，因为距离计算通常是在离线阶段完成的。不过也不一定是这样。借助 GPU 的强大处理能力，完全可以从任意的前景-背景图像中通过距离变换生成距离场。一种适合并行实现的方法是“跳跃洪泛算法”（Jump Flooding Algorithm，简称 JFA）。该算法最初由 Danielsson 在1980年提出 [https://doi.org/10.1016/0146-664X(80)90054-4]，但由于当时并行硬件尚未出现而被遗忘。后来 Guodong Rong 独立重新发明并在2006年发表 [https://dl.acm.org/doi/10.1145/1111411.1111431]。尽管 JFA 允许逐帧计算距离场，但如果形状是静态的，距离变换最好还是作为预处理步骤执行，并将其存储为跨帧持久存在的纹理。

本书封面就是一个使用距离场渲染形状的例子。球体上的文字是通过抗锯齿阈值处理一个编码为 RGB 纹理的带符号距离场来渲染的，其中使用了两个通道来以 8.8 固定点格式编码距离值。之所以选择在 8 位图像中使用两个通道而不是原生 16 位格式，是为了兼容性考虑。许多图形 API 仅支持 8 位图像文件格式作为纹理输入，因此有时在 8 位 RGBA 中编码“奇怪”的数据，并让着色器将其转换为目标格式，是一种不错的选择。

在这种特定情况下，欧几里得距离变换是通过 Gustavson 和 Strand 在2010年发表的抗锯齿扩展方法实现的 [https://doi.org/10.1016/j.patrec.2010.08.010]。出于多种原因，该变种算法比传统的二值图像距离变换更适合于从图像数据生成带符号距离场。

![2506290350 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/06/29/1mg/2506290350-.png)
*封面图像（左）中显示的文字是由右侧采样的距离场渲染而成。*

	

## **再见了**

程序化纹理技术可以做很多有趣且有用的事情，不可能在一本书中涵盖所有内容。我甚至不能假装自己已经了解全部，而且这个领域的许多聪明人总是在不断产生新的想法。这个主题仍在不断发展和扩展。

希望这本书为你提供了一个全面的概览，并介绍了基本原理，而没有走太多捷径。计划出版第二部分，但会聚焦于程序化几何的基础知识，而不是进一步深入程序化图案这一迷人又有趣的主题。至此，你应该已经准备好去阅读研究论文以及高级实践者的详细案例研究了。Shadertoy（[www.shadertoy.com](http://www.shadertoy.com)）作为一个便捷且跨平台的工具，适合实验和分享创意，你或许也想用它来进行自己的着色器实验。

祝你玩得愉快！

