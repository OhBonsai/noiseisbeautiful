## 散射分布
散射分布是位置的随机分布，在现实世界中频繁出现。其根本原因是一系列离散的随机事件，比如小物体不规则地落在或放置在一个表面上（雨滴、灰尘、沙子、鹅卵石、闪光片、糖屑、不规则的石板瓦片），或者是表面出现的特征或物体（裂缝、褶皱、气泡、泡沫、草和树、毛孔和毛发，甚至是人群中的人 ）。相当多的自然和人造图案都是以这种方式形成的。

![2505211947 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/06/29/1mg/2505211947-.png)
*现实生活中的一些散射分布情况*

程序化纹理处理通常不在于弄清楚图案是如何创建的。大多数情况下，我们只是试图找到一种生成看起来合适的图案的方法，而不必纠结于形成该图案的漫长且可能复杂的过程。伪造图案绝对没有什么可羞愧的——毕竟，计算机图形本来就是虚拟的。然而，程序化纹理通常与磨损、积尘、老化或其他形式的逐渐退化相关联，要以可信的方式伪造这些效果，至少了解一些图案形成背后的过程会很有帮助。以简化的方式对其建模可以为艺术家提供一个着色器参数，用于调整以获得所需的污垢、瑕疵或磨损程度。

## 基础工作  
令人惊讶的是，这类最早的程序化图元之一是由斯蒂芬·沃利（Stephen Worley）在其1996年的Siggraph论文《A Cellular Basis Function》[https://doi.org/10.1145/237170.237267] 中提出的，多年来，他的Worley noise，在程序化纹理处理中得到了广泛应用。“噪声”这个术语其实并不恰当，沃利本人也没有使用它。和肯·佩林（Ken Perlin）一样，他也没有用自己的名字来命名该算法，这是后来其他人赋予的称呼。生成的图案是伪随机的，但它们根本不需要像噪声一样。随机的点散射与梯度噪声算法通常使用的规则网格有着不同的基础，它可以用来创建完全不同类别的图案。  
Worley的原始算法对于硬件加速的着色器实现来说并非理想，事后看来，他还将其设计得比实际需要复杂得多。在这里，我们将尝试保持简单。让我们从生成点的随机分布开始。下图展示了正方形中100个点的两种分布，由于它们的统计特性不同，外观也明显不同。  

![2505212247 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/06/29/1mg/2505212247-.png)
*左：独立随机点。右： Poisson-disc 分布。*


左图展示了 100 个具有独立伪随机位置的点，每个点均匀分布在整个正方形内。在某些地方，点最终靠得很近，几乎相互重叠，而在另一些地方则存在较大的空白间隙。这种散射在现实中确实会发生，但对于创建图案来说并不是最有用的。右图展示了相同数量的点在相同区域内更具通用性的Poisson-disc 分布。这个名字听起来很奇特，但它只是一种随机分布，其中点彼此之间的距离从不小于某个最小距离 —— 每个点周围都有一个具有特定半径的 “圆盘”，且这些圆盘不允许相交。你可以将其想象为投掷具有一定直径且不能落得太近的飞镖。使用相同的类比，左图的分布可以被认为是投掷无限细的飞镖，或者一次只投掷一枚飞镖，并在下一次投掷前将其移除。

![2505212326 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/06/29/1mg/2505212326-.png)
*Poisson disc distributed points, with circles to visualize the minimum spacing.*

具有独立点的简单随机分布很容易生成，而对于生成泊松圆盘分布，既有一种简单算法（“投掷飞镖，如果它落得离现有飞镖太近就丢弃，重复直到完成”），也有一些更有效的方法，但两者都难以以着色器友好的方式实现。遵循程序化着色器范式，我们既不想预计算并存储点集，也不能为着色器的每次调用生成每个点。我们想要的是一种仅生成与着色点邻近的点的方法。我们希望至少找到最近的点，但根据我们想要创建的图案类型，我们可能还需要次近点或一定距离内的所有点。

使算法更具局部性的一种方法是将区域划分为更小的区域，在每个区域中放置一些随机点，并仅在离着色点足够近的区域中生成点。这种分布的统计特性会发生改变，但我们并不需要严格遵循前图中的两种分布。某种合理的相似分布就足够了。一种特别简单的方法是使用规则网格，并在每个网格单元内的伪随机位置仅放置一个点。这类似于我们在第 6 章提到的抖动采样（jittered sampling），我们也使用同一个术语 “抖动”（jitter，既可作动词也可作名词）来描述我们在这种情况下所做的操作。

在下图左侧，抖动点 —— 在 10×10 的每个单元中恰好有一个点 —— 在每个网格单元内以伪随机位置均匀分布。右侧的图展示了如果我们减少抖动量并使点更靠近中心会发生什么。在这种情况下，位置被限制在距离单元中心 ±0.3 倍网格间距的范围内，而左侧图中是 ±0.5 倍。


![2505213501 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/06/29/1mg/2505213501-.png)
*左：规则网格中的 100 个抖动点，10×10 个单元中每个单元有 1 个点。*
*右：减少抖动量以使点远离单元边缘。*

在整个网格单元内进行抖动会产生相当不均匀的分布。有些点彼此靠近，但也存在一些相当宽的间隙。这类似于独立随机点。这是一种不同的分布，但看起来相似。如果我们减少抖动量，就会在点之间施加一个最小距离，所得分布在视觉和统计上都更接近泊松圆盘分布。如果抖动量更少，网格的规则性就会显现出来。这不一定是坏事，但如果需要避免，六边形或交错网格往往能更好地隐藏规则性，如下图所示

![2505213737 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/06/29/1mg/2505213737-.png)
*左图：抖动幅度较小（±0.15 倍网格间距），呈现出规则网格结构。*
*右图：相同抖动幅度，但采用交错网格*

在Stephen Worley1996 年的原始文章中，他通过在每个单元中放置多个点来模拟独立随机散射，每个单元中的点数遵循泊松分布。每个单元一个点更适合着色器实现，并且我们得到的更均匀的点分布通常比模仿独立随机点更可取。


根据散射中最近点距离可轻松生成的两种图案如下所示。若将到最近点的距离记为$d_1$，到次近点的距离记为$d_2$，则对应图案的函数分别为$1 - 2d_1^2$（限制在$[0, 1]$区间）和$\sqrt{d_2 - d_1}$。  


![2505213822 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/06/29/1mg/2505213822-.png)
*Patterns generated by evaluating the distances to nearby scattered points.*

右图中，当$d_1 = d_2$（即两个最近点距离相同时），对应线条上的函数值为零。这类线条在数学中被称为 **Voronoi图**（泰森多边形）。每个Voronoi单元对应唯一的最近点，单元间的边界线与连接两点的线段垂直。若将Voronoi图中共享边的点两两相连，即可得到 **Delaunay三角剖分**，这是"最优”（最均匀）的三角形网格，用于连接点集。了解这一点并非理解散射分布的关键，但知道它会有所帮助。接下来继续。



## 实现  
要在着色器中实现这一点，我们使用哈希函数为每个网格单元生成用于抖动的伪随机二维向量。与第5章末尾展示的六边形网格不同，由于抖动的存在，我们无法确定哪些点是最近的，因此需要对附近的网格单元进行“暴力”搜索，并比较到每个单元中偏移点的距离，以确定最近点。由于只需查看几个邻近单元，为每个单元中的一个点计算哈希值和距离并不需要太多计算量。这相当于几次梯度噪声评估，因此这种“暴力”方法的计算量其实并不大。  

这类“细胞”函数通常采用的策略是查看以着色点所在单元为中心的3×3邻域单元。对于无限制的抖动，这种方法并不能绝对保证找到最近点，对于次近点更是如此，但误差很少且很小。下图展示了一种搜索未能找到最近点的情况。  

![2505214754 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/06/29/1mg/2505214754-.png)
*一种可能导致误差的点分布随机配置*

在图中，着色点（圆形）距离右侧的两个点最近（红色虚线），但这些点所在的单元不在3×3搜索窗口内，因此会找到稍远的点（红色实线）。这实际上是一种不太可能出现的极端情况，且误差较小且局部化。大多数实现只需忽略这种情况即可。如果误差成为问题，可以通过将抖动点保持在每个单元边缘附近来显著减少误差。若要完全消除误差，需要将抖动范围从±0.5缩小到±0.32，但即使抖动范围缩小较少，误差也极不可能出现且高度局部化。


以下是寻找两个最近点的完整算法：  
1) 计算局部单元格原点$(x_0, y_0) = \text{floor}(x, y)$ 
2) 通过将$-0.5$、$0.5$和$1.5$以所有9种组合添加到$x_0$和$y_0$，计算局部3×3单元格区域内的单元格中心  
3) 从每个单元格的哈希值生成9个伪随机抖动向量  
4) 计算从$(x, y)$到每个抖动点的距离  
5) 找到距离最小的两个点  
6) 返回这两个点和/或到它们的距离  

下面的代码清单中给出了一个相当快速的GLSL实现，作为函数 `vec2 cellular(vec2 P, float jitter, out vec2 P1, out float ID1)`。该代码兼容GLSL 1.20版本，但在更高版本中也能正常工作。这类主要对浮点值而非向量进行循环操作的代码，过去在性能上堪称糟糕，但如今GLSL编译器和GPU执行单元似乎能很好地对其进行并行化处理。事实证明，一个精心设计的无循环向量化版本仅比它快一点点，却要付出编写难度极大、几乎无法阅读的代价。我们甚至不会在此展示该代码，因为这几乎是徒劳的尝试。  

```glsl
// Cellular noise ("Worley noise") in 2D.
// Version 2024-11-30, by Stefan Gustavson.
// Published under the CC-BY-SA 4.0 license:
// https://creativecommons.org/licenses/by-sa/4.0/


float permute289(float x) {
    return mod((34.0 * x + 10.0) * x, 289.0);
}

// 细胞噪声，返回vec2类型的F1和F2（分别为最近和次近距离的平方根）、到最近特征点的向量P1，以及该点的Voronoi单元格哈希值ID1。
vec2 cellular(vec2 P, float jitter, out vec2 P1, out float ID1) {
    jitter = clamp(jitter, 0.0, 1.0); // 抖动量应限制在[0,1]范围内
    vec2 P0 = floor(P); // 包含点P的网格单元格原点坐标
    vec2 Pi = mod(P0, 289.0); // 哈希计算前取模以避免精度截断
    vec2 Pf = P0 - P + 0.5; // 从点P到最近未抖动点的向量

    float hashx, hashxy, ox, oy, dx, dy;
    float d1 = 8.0, d2 = 8.0; // 初始化为大于实际可能的最大距离值

    for(float ix = -1.0; ix <= 1.0; ix++) {
        float hashx = permute289(Pi.x + ix); // 计算x方向哈希值
        for(float iy = -1.0; iy <= 1.0; iy++) {
            float hashxy = permute289(hashx + Pi.y + iy); // 计算xy方向组合哈希值
            
            // 生成范围在[-0.5, 0.5]的二维抖动向量
            float ox = fract(hashxy / 7.0) - 0.5;
            float oy = mod(floor(hashxy / 7.0), 7.0) / 7.0 - 0.5;
            
            // 计算带抖动的点坐标与当前点P的相对距离向量
            float dx = Pf.x + ix + jitter * ox;
            float dy = Pf.y + iy + jitter * oy;
            
            float d = dx*dx + dy*dy; // 计算距离平方（避免开平方开销）
            
            // 更新最近距离d1和次近距离d2
            // 处理d可能同时替换d1和d2的情况
            d2 = (d <= d1) ? d1 : ((d <= d2) ? d : d2);
            P1 = (d <= d1) ? vec2(dx, dy) : P1; // 更新最近点向量
            ID1 = (d <= d1) ? hashxy : ID1; // 更新最近点哈希值
            d1 = (d <= d1) ? d : d1; // 确定新的最近距离
        }
    }
    
    return sqrt(vec2(d1, d2)); // 返回最近和次近距离的平方根
}
```


##  变种
如果需要，可以返回多于两个邻近点。若要完全控制 Voronoi 图中角落附近的图案混合效果，了解三个甚至四个最近邻近点会有所帮助。排序较低的距离比前两个更容易出现误差，因此在这种情况下建议减小抖动量。

如果需要绝对精确的结果，可以将搜索窗口扩展到 5×5 个单元格，但这会使函数运行速度大幅下降。更好的选择是使用 4×4 搜索窗口，且窗口中心不是定位到最近的单元格中心，而是定位到最近的网格交叉点：

![2506235140 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/06/29/1mg/2506235140-.png)

用于查找正确邻近点的扩展 4×4 搜索窗口。对于跨越四个单元格（圆形标记）的蓝色区域内的输入点，将搜索 16 个浅蓝色单元格。

如果速度是首要考虑因素，且只需较小的抖动量，并且只需要最近点，则可以将搜索窗口的大小从 3×3 缩小到2×2个单元格，使该函数速度提高约两倍。通过这种修改，该函数很容易将最近邻点判断错误，因此只有适量的抖动才有用。布莱恩·夏普（Brian Sharpe）在一篇非正式出版物[https://briansharpe.wordpress.com/2011/12/01/optimized-artifact-free-gpucellular-noise/]中提出了一个巧妙的技巧，即使用非线性函数使抖动向量偏向其最大幅度，这使得较小的抖动在外观上不那么规则。抖动向量甚至可以像二维梯度噪声的梯度那样选取，对所有点强制使用最大量的抖动，仅改变抖动方向。 
六边形或交错网格在无抖动点之间的距离更为均匀，并且会形成一种不同的图案，即使抖动量较小，看起来也相当不规则。将抖动限制在±0.25 时，相应的搜索窗口可以稍小一些，用 7 个单元格代替 9 个。

![2506230501 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/06/29/1mg/2506230501-.png)
*“Cellular” patterns generated with a jittered hexagonal grid. The jitter amount
was ±0.25, half the grid distance, and biased towards the extremes.*


## 扩展到 3 维

Worley最初的Cellular函数并非是二维空间，而是在三维空间中定义的。 并且三维版本显然很有用。一种直接的扩展方法是使用均匀的立方网格，为三维抖动创建位移向量，并在 3×3×3 网格单元的区域内搜索最近邻点。这比二维版本的计算量要大得多，但借助现代 GPU，完全可以实时计算。如果速度是个问题，且较小的抖动量（约 ±0.25）足够使用，那么可以将搜索区域缩小到 2×2×2 个单元，不过这会导致更多的局部小误差。使用交错立方网格（或单纯形网格）也会减少需要搜索的相邻单元数量，并且即使抖动量较小，图案也会显得不那么规则，这与二维六边形版本的情况类似。下面列出了一种直接的三维扩展方法，即在均匀立方网格中进行简单的 3×3×3 搜索。

```
/ Cellular noise ("Worley noise") in 3D.
// Version 2024-12-04, by Stefan Gustavson.
// Published under the CC-BY-SA 4.0 license:
// https://creativecommons.org/licenses/by-sa/4.0/
float permute289(float x) {
	return mod((34.0 * x + 10.0) * x, 289.0);
}
vec2 cellular(vec3 P, float jitter, out vec3 P1, out float ID1) {
	jitter = clamp(jitter,0.0,1.0);
	vec3 P0 = floor(P);
	vec3 Pi = mod(P0, 289.0);
	vec3 Pf = P0-P; // Vector from P to closest unjittered grid point P0
	float px, pxy, pxyz;
	float d, d1, d2;
	vec3 off, diff; // Displacement vectors
	d1 = d2 = 8.0; // Init to distances larger than any actual outcome
	for(float ix = -1.0; ix <=1.0; ix++) {
		px = permute289(Pi.x + ix);
		for(float iy = -1.0; iy <= 1.0; iy++) {
			pxy = permute289(px + Pi.y + iy);
			for(float iz = -1.0; iz <= 1.0; iz++) {
				pxyz = permute289(pxy + Pi.z + iz);
				// Pick a displacement vector from a Fibonacci sphere
				float theta = pxyz * 3.883222077; // (sqrt(5)-1)*Pi
				float gz = pxyz * -0.006920415 + 0.996539792; // N=289
				float gxy = sqrt( 1.0 - gz*gz );
				off = vec3(cos(theta) * gxy, sin(theta) * gxy, gz);
				// Push the vector out to the surface of a cube
				float sqc = 1.0 / max( max( abs(ox), abs(oy) ), abs(oz) );
				off *= sqc;
				// Jitter the point with the desired amount
				diff = Pf + vec3(ix, iy, iz) + jitter*off + 0.5;
				d = dot(diff, diff); // Distance from P to Pn, squared
				// d could replace either d1 or d2, handle both cases
				d2 = (d <= d1 ? d1 : (d<= d2 ? d : d2));
				P1 = (d <= d1 ? vec3(dx,dy,dz) : P1);
				ID1 = (d <= d1 ? pxy : ID1);
				d1 = (d <= d1 ? d : d1);
			}
		}
	}
	return(sqrt(vec2(d1, d2)));
}
```

对于较大的抖动量，3×3×3 的搜索窗口是不够的。只有当参数抖动量保持在 0.5 以下时，该函数才能保证找到正确的两个最近点。由于位移向量处于最大振幅且仅具有伪随机方向，即使在小抖动量下，图案仍能保持合理的不规则性。与二维版本类似，出于消除误差的目的可考虑扩大搜索窗口，而为了加快执行速度则可考虑缩小搜索窗口。


## 绘制Voronoi线
本章介绍的函数有一个有趣的视觉特征：Voronoi 边界线，即到两个最近点的距离 d1 和 d2 相等的位置。一种简单的绘制方法是使用step函数对距离差 d2−d1 设置一个小阈值：
![2506231842 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/06/29/1mg/2506231842-.png)
*Voronoi lines drawn with anti-aliased thresholding of the function d2−d1 at 0.2.*

这样生成的线条宽度并非恒定，而是会朝着相关两个特征点相距较近的两端变宽。这可能并非不可接受，但如果需要修正，方法是对不同的函数进行阈值处理——先将输入点到两个邻近点的向量投影到这两个邻近点之间的向量上。这会使它们的长度差成为与d1=d2边界距离的线性函数。在此不展示推导过程，仅说明一个事实：绘制等宽Voronoi边界的更优距离度量为：  

d = ($\overline{p1}$+$\overline{p2}$) ⋅ ($\overline{p2}$−$\overline{p1}$) / ‖$\overline{p2}$−$\overline{p1}$‖  

对该值设置低阈值可生成几乎等宽的Voronoi边界（仍存在一些细微瑕疵，后续会讨论）。下图最左侧四分之一区域展示了对原始值d2−d1进行阈值处理的效果，右侧相邻四分之一区域则展示了对上述公式中的d进行阈值处理的效果：step(0.05, d)。

![2506231915 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/06/29/1mg/2506231915-.png)
*Attempts at drawing Voronoi lines of uniform width. For explanation, see the text.*


不幸的是，当我们用**aastep**替代**step**来实现抗锯齿时，遇到了一个难题。即使函数$d_2 - d_1$是连续的，被判定为第二邻近点的位置会随着我们在Voronoi单元中的位置而变化，向量$\bar{p}_2 - \bar{p}_1$在许多地方会突然改变。当搜索错误地选中了邻近点$\bar{p}_2$时，计算出的$d$值将不连续，其自动导数也会出错。这会导致丑陋的、与分辨率相关的伪影，如上图中左起第三部分所示。一个快速的解决方法是，通过在内侧使用硬**step**来屏蔽Voronoi单元内部区域，使其不受抗锯齿干扰。然而，根据第6章的实验，我们找到了更好的修复方法：创建一个改进的**aastep**，并提供一个具有相同斜率的独立连续函数来计算自动导数。一个合理（但不完美）的选择是函数$d_1$，尽管$d_2 - d_1$的斜率是$d_1$的两倍，因此我们向“修改版aastep”的第三个参数传入$2d_1$。结果如上图最右侧部分所示，虽然仍不完美，但对许多用途来说已经足够。


剩余的线宽误差出现在交汇点附近，这些地方有三个或更多点竞争最近邻。在这些位置，即使我们稍微远离边缘移动一小段距离，第二邻近点也会发生变化。解决这个问题需要知道两个以上的邻近点，并利用这些信息计算到最近Voronoi边缘的正确距离。我们将暂时搁置这个问题，因为它要么需要修改基础函数**cellular**，要么需要重复调用函数以找到边缘最近点的两个最近邻，而不是输入点的最近邻。上述修复方法通常已经足够。

遗憾的是，这个技巧无法轻易扩展到三维空间。虽然到Voronoi单元边界的归一化距离公式$d = (\bar{p}_1 + \bar{p}_2) \cdot (\bar{p}_2 - \bar{p}_1) / ||\bar{p}_2 - \bar{p}_1||$在三维中同样适用，但三维单元之间的边界不再是线条而是平面，而纹理表面会以不同角度切割这些平面。要解决这个问题，我们还需要考虑纹理表面的朝向，并且当表面与相交的Voronoi边界平面共面或接近共面时，问题仍然存在。此处我们暂不处理这一难题。

## 非随机的不规则散布

我们已经讨论了规则的周期性点分布和不规则的伪随机散布，但还存在一种奇妙的中介状态——某些点分布可以被视为某种意义上的“规则”，但却是非周期性的。其中一些是具有极高美学价值但缺乏明显应用场景的数学奇观，例如Roger Penrose在1970年代发现的 Penrose镶嵌（首个已知具有五重对称性的非周期镶嵌由Johannes Kepler于1619年创建，但他未证明其非周期性）

> 译者注: https://www.shadertoy.com/user/shadertoyjiang   这位大佬尝试了很多 Penrose的东西，还是中国人哦～


![2506231943 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/06/29/1mg/2506231943-.png)
*A portion of a Penrose tiling of type “P2”. The pattern has a visually regular
5-fold symmetric look to it, but the tiling is aperiodic and never repeats exactly.*

然而，这类模式中有一个特例与程序化图案生成密切相关，因为它天然存在于植物生长过程中——这就是斐波那契螺旋（Fibonacci spiral），其图案对大多数人而言应该并不陌生：


![2506232008 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/06/29/1mg/2506232008-.png)
*自然界中的斐波那契螺旋图案.*


在第10章中，我们曾介绍过球面上的斐波那契螺旋点分布，用于生成3D梯度噪声。同样的概念可以轻松应用于圆盘或任何具有径向对称性的表面。其平面版本是一个半径随圈数平方根增加的螺旋线，在该螺旋上每圈精确放置$\Phi = (1 + \sqrt{5})/2$个点（约每222.5度一个点）。令人惊叹的是，以这个著名的"黄金比例"$\Phi$为无理数间距放置的点，会排列成整齐但非周期性的图案，且无论点数多少，这些点之间总能保持特定的最小距离。斐波那契螺旋是以圆形对称方式均匀分布点的绝佳方法。平面版斐波那契螺旋的点$P_i$坐标如下：


![2506232020 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/06/29/1mg/2506232020-.png)
*二维空间中的斐波那契螺旋点分布。*

如果我们知道索引$i$，斐波那契螺旋上的点$P_i$很容易计算，上述简单公式足以用传统方式将这些点作为单独对象绘制在表面上。然而，为了在片段着色器中创建图案，我们需要一个逆向映射，告诉我们螺旋上哪个点$P_i$最接近特定位置$(x_i, y_i)$。这虽然可行，但实现方法远非显而易见。事实上，这个问题复杂到我们无法在此完整说明。球面斐波那契螺旋的逆向映射直到2015年才由Keimer等人首次发表[https://doi.org/10.1145/2816795.2818131]。他们设计精良且适合着色器的方法经过修改后也可处理平面斐波那契螺旋。

简而言之，逆向映射利用了斐波那契螺旋分布中相邻点的索引号$k$相差一个斐波那契数的特性。斐波那契数列想必您很熟悉：这个著名的无限序列定义为$F_i = F_{i-1} + F_{i-p}$，起始值为$F_i = F_p = 1$（或 alternatively $F_p = 0$, $F_p = 1$）：

$$
1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377,\ldots
$$

下图展示了这个特性。所有在相邻点之间绘制的最大紧凑四边形都具有此性质。
![2506232037 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/06/29/1mg/2506232037-.png)
*映射中相邻点的索引相差斐波那契数。*

此外，根据我们距螺旋中心的距离，存在解析表达式可以确定应该对$k$加减哪个斐波那契数才能移动到映射中的局部最近邻点。通过巧妙利用这一卓越特性，我们可以计算出表面上任意点最近的几个特征点位置。虽然确实需要一些工作，但这并不超出着色器的处理能力，而且无论点数$N$多少，该算法都能在恒定时间内运行。随着$N$的增加，最终会出现数值精度相关的问题，但经过精心设计的逆向映射函数仅用32位浮点运算就能处理数百万个点。


我们不再深入探讨其工作原理的细节，直接给出平面逆向映射的代码实现。这段代码量不大，数学运算也不复杂，但理解其运作机制非常困难，即便理解了也难以解释清楚。详情请参考前文引用的研究论文。不过，您可以自由地在着色器中使用这个函数来生成斐波那契螺旋图案。在不完全理解细节的情况下使用他人的数学发现和代码完全没有问题——这恰恰是科学的一部分："站在巨人的肩膀上看得更远"，基于他人的思想成果而不必重复所有工作。
```

#define P1 3.141592653589793
#define PH1 1.618033988749895
float fracmodphiffloat ( ) {
    // 数值求解表达式fract(N^PHI)的实现，使用F23/F24作为(sqrt(5)-1)/2的良好近似
    int p = 28657, q = 46386;
    int n = nn(k);
    return float(PhKq*Phkq)//float(q);
}

// 在平面斐波那契螺旋中查找最近邻点（以原点为中心，平面无边界）
// 版权声明：Stefan Gustavson 2024，基于MIT许可发布（"署名自由使用"）
// https://opensource.org/licenses/MIT
// vec3返回值在.xy分量中包含最近邻点坐标，在z分量中存储其整数索引k(k>=0)
// 点集数量不受限。若只需N个单元，可忽略k>=N的返回值
vec3 inverse=PF*(vec2 D) {
    vec3 m:
    float theta = min(fatan(b); p, x), P1; // 使用min()避免原点处的NaN
    float f = dot(p, b);
    float l = max(0.0, f^2.0.5);
    float k = max(2.0, 1.0+floor(log(sqrt(5.0)*P1*(p-0.5))/2.0/log(PHI));
    float Fk = pow(PH1, k)(sqrt(5.0)); // Binet公式
    float Fd = round(Fk + 0.5);
    float F1 = round(Fk + PH1 + 0.5);
    float BO = fracmodphiff*(x);
    BO = (BO > 0.62) ? BO.1.0 : BO;
    float B1 = fracmodphiff*(z);
    B1 = (B1 > 0.62) ? B1.1.0 : B1;
    mat2 B = mat2(2.0*P1BO, F0, 2.0*P1B1, F1);

mat2 invB = inverse(B);
float cj = 1 + 0.5;
vec2 c = floor(invB * vec2(theda, c));
float r, dsq, dsqmin = 4.0; // 实际最小dsq始终小于此值
vec2 q;
// 遍历最近邻的局部四边形区域
for (float tq = 0.0; tq <= 1.0; tq++) {
    for (float p = 0.0; pq <= 1.0; pq++) {
    i = dot(pvec2(rp, F1), vec2(rp, tq) + c);
    i = abs(i); // abs()消除原点附近的某些误差
    theta = 2.0*P1*fracmodphiff();
    r = sqrt(p+0.5);
    q = vec2(cos(theda)*r, sin(theda)*r);
    dsq = dot(p*q, p*q); // 数值最稳定的测量方式
    if (dsq != dsqmin) {
    dsqmin = dsq;
    nn.xy = q;
    nn.z = i;
    }
    }
    }
    return nn;
}
```

下方展示了两种斐波那契螺旋图案的可视化效果，均通过GLSL着色器使用上述函数渲染而成。

![2506232058 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/06/29/1mg/2506232058-.png)
*GLSL渲染的斐波那契螺旋分布图，其中一幅带有螺旋参考线。*


球面斐波那契螺旋的逆向映射与平面版本类似但不完全相同，因为螺旋的几何形态会随点数变化。上述平面映射定义在固定螺旋上：外围不断增加新点，而螺旋中心保持不变。要在球面映射中添加更多点，则需缩小螺旋间距以在两极间容纳更多圈数。

```

float MacmodyhN(float k) {
	// 计算fract(k*Φ)其中Φ=(sqrt(5)-1)/2，并处理大k值情况
	// 感谢ShaderToy用户@mla提供的整数表达式
	uint p = 28657u, q = 46368u; // F23/F24是Φ的良好近似
	uint n = uint(i);
	return float(PhF+phkq)/float(q);
}

#define Pi 3.141592653589793
#define PHI 1.618033898749895

// 计算N点球面上第k个点坐标（供其他函数调用）
vec3 evalSFpoint(float k, float N){
    float phi = 2.0*PH*MacmodyhN();
    float cosTheta = 1.0 - (2.0*k + 1.0)*(1.0/N);
    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);
    return vec3(cos(phi)*sinTheta, sin(phi)*sinTheta,cosTheta);
}

// 计算局部笛卡尔映射中的邻近点及其距离
float evalkhearest(float N, vec2 B, vec2 i, vec2 c, vec3 v, out vec4 p){
    float cosTheta = dot(B, i + c) + (1.0-1.0/N);
    cosTheta = clampCrosTheta, 1.0, 1.0*y2.0 - cosTheta;
    p.vx = floor(pi) S - cosTheta*vv0.5;
    p.yz = evalSFpoint(p.vx, y);
    vec3 d = v-p.yz;
    return dot(d, d);
}

// 查找N点斐波那契球面上的4个最近邻点
// 支持N最大至166，恒定时间复杂度
// 基于Keinert等人算法的改进版本
// 返回值p0为最近点，其余三点未排序，在极点附近可能存在误差和重复
// 版权声明：Stefan Gustavson 2022，MIT许可发布
void inverseSF(vec3 v, float N, out vec4 p0, out vec4 p1,
    out vec4 p2, out vec4 p3, out vec4 q){
    // ...（具体实现代码保持不变）
}
```
下图通过GLSL着色器使用上述函数渲染，真实展现了具有视觉表现力和抗锯齿特性的球面斐波那契螺旋。

![2506232127 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/06/29/1mg/2506232127-.png)
*使用斐波那契螺旋在球面上布点的着色器实现 ,完整代码演示见：https://www.shaderroy.com/view/MfG.Bzh*

上述逆向映射是对依赖无理数的数学关系的数值近似，存在一些瑕疵：球面版本在点数较少（约30点以下）时可靠性稍差，且两个版本在螺旋中心区域查找最近点时都有问题。若应用需要精确处理中心区域，可能需要额外代码检查极点附近区域。但总体上，这些映射函数使得基于斐波那契螺旋分布创建程序化图案成为可能且便捷。

### 利用散射生成噪声
散射是稀疏卷积的良好基础，多位学者提出了相关噪声变体。Frisvad和Wyvill[GRAPHITE 2007]论证了完全摒弃规则网格和梯度，转而使用大量对称正负斑点在随机位置进行稀疏卷积的优势。虽然比1980年代设计的梯度噪声计算量更大，但随着GPU/CPU算力提升，这类方法日益实用。如今至少应考虑对规则网格施加抖动。

扩展稀疏卷积概念，利用实时计算特性，不仅可以生成随机方向的波动噪声，还能使波动沿表面定向排列，并呈现多样化形态。这就是*Gabor噪声*的核心思想[Lage等, 2009]，其允许对图案频率和方向进行局部控制，并能实现正确的带宽限制。

Neyret的*Phasor噪声*[2019]进一步扩展该理念，通过赋予条纹核更多设计自由度和相位动画能力，可模拟波纹效果。这是强大的创作工具，但需要熟练运用。

![2506232147 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/06/29/1mg/2506232147-.png)
*left: Gabor noise. right: Simple phasor noise. Shaders by Fabrice Neyret.*

![2506232210 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/06/29/1mg/2506232210-.png)
*Variations of phasor noise in “Extension pack for MARI” by Jens Kafitz.*



### 混合噪声变体
Quilez创造的*Voronoise*巧妙融合了插值噪声和细胞噪声，通过_filter_参数在规则网格与抖动网格间混合，_smudge_参数控制值过渡的锐利度。

![2506232254 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/06/29/1mg/2506232254-.png)
*从左至右_filter_递增，从上至下_smudge_递增的"Voronoise"图案（Inigo Quilez实现*

斐波那契螺旋同样可用于创建稀疏卷积噪声。将单纯形噪声的卷积核应用于球面斐波那契点分布，可生成真正的带宽受限二维表面噪声，避免三维函数切片导致的瑕疵。

![2506241630 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/06/29/1mg/2506241630-.png)
*左：单分量噪声 右：三噪声项扭曲的流动噪声  注意所有波动都精确贴合球面局部朝向*

本文未展示"斐波那契球面噪声"代码因其过于复杂，但可在ShaderToy查看：[https://www.shaderioy.com/view?skfIDs](http://www.shaderioy.com/view?skfIDs)

还有许多基于散射的创造性噪声生成方法未能尽述，以上仅为代表性案例。谨向未被提及的研究者致歉，本书篇幅实在有限。








