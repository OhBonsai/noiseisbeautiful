在上一章中，我们简要提到编写良好的程序化着色器可以自行执行抗走样操作。这一点值得重申，并且强烈建议大家实际去这么做。甚至值得为它单独加个框：
<div style="text-align:center; background-color:#d6e977; padding:10px;color:black">
A well written procedural shader can,
<br/>
and should, perform its own anti-aliasing.
</div>

（如果这听起来像是不必要的说教，我表示歉意。这是一本教科书，而我在授课，但我不想惹恼读者。嗯，尽量不要太惹人烦。）
必须强调的是，在程序化着色器中，锯齿现象是可以避免的，并且在所有视觉质量至关重要的情况下都应该避免。尤其是当人们在编写着色器时不够谨慎，表面图案中的走样现象可能会非常严重。对于初学者和创意实验来说，这或许尚可接受，但对于正式的制作而言，这是绝不能被原谅的。 
烹饪中有一个恰当的比喻：“米饭煮不熟是不可原谅的。”在盛饭之前，很容易就能检查米饭是否煮好。同样，在发布程序纹理着色器之前，也可以很容易地检查其是否存在锯齿问题。这个比喻并不完美，因为煮不熟的米饭只需继续煮到熟透就行，而程序纹理着色器中的锯齿问题却可能需要花费大量功夫才能修复。尽管如此，这仍是一个值得牢记的好比喻。煮不熟的米饭会毁掉一顿原本很棒的饭菜，而走样则会毁掉一幅原本很棒的图像。 

## Aliasing的种类
在上一章中，我们提到锯齿边缘是混叠的一种类型。另一种是采样间距与底层图案之间的干扰，称为摩尔纹。这两种情况在下面的测试图案中都有明显体现。
![2505024105 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/05/1mg/2505024105-.png)

如你所见，即使在采样频率非常高的情况下，不规则的莫尔条纹仍然很明显，甚至当单个像素小到人类观察者无法看到时也是如此。这是因为我们对一种过于精细的图案进行了欠采样，以至于在选定的分辨率下无法以像素形式呈现。高频（微小细节）被误解为较低频率（较大细节）。有时，即使采样频率很高，莫尔条纹也会出现非常低的频率

在动画中，走样也会导致强烈的闪烁和“频闪效应”，使人对运动的速度和方向产生混淆。遗憾的是，我们无法通过书面形式很好地展示这一点，但可以将其视为与莫尔条纹等效的时间采样问题：帧率不足以准确反映图像中以更高频率发生的变化，最终采样序列可能会显示出严重错误的运动信息。

## Aliasing的原因

> 译者注：  理解Aliasing是由于采样导致非常关键，关于采样可以学习 GAMES101 https://www.bilibili.com/video/BV1X7411F744 。

现在，在深入探讨抗锯齿究竟是如何实现之前，我们不妨先退一步，简要解释一下“Aliasing”实际上是什么，以及这个名称的由来。在尝试寻找解决方案之前，确切了解问题所在总是有益的。这个原理在一维图中解释得更为清楚。根据著名的采样定理（该定理常以Nyquist命名，但实际上应归功于香农，或者更确切地说，归功于信号处理领域的几位先驱，包括但不限于Borel, Ogura, Whittaker, Kotelnikov, Raabe,
Shannon, Weston and Someya,，但我跑题了），我们需要对周期信号进行采样，采样频率必须严格高于每个周期两次，否则就无法从样本中重构原始信号。重构尝试会错误地将样本解释为来自频率较低的信号。换句话说，采样不足的高频信号在重建中会以一个不同的、频率较低的混叠信号出现。这就是它被称为 “走样Aliasing” 的原因。


![2505024452 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/05/1mg/2505024452-.png)

清晰边缘出现的锯齿状边缘也是同样的原因。颜色的急剧变化是一种不连续性，但信号处理理论假定所有被采样的信号都是连续的（正式说法是连续性是必要条件）。因此，具有锐利边缘的图案在进行点采样时，必然会产生错误的伪像——即 “锯齿状边缘”——而这些伪像在底层信号中并不存在。



## 经典补救手法
为减少Aliasing现象，着色器可以进行多重采样或超采样。这些术语的确切定义会因上下文略有不同，但它们本质上都是对图案进行过采样：对每个像素在多个点进行采样，然后取结果的平均值。这是区域采样的一种近似方法，区域采样是处理非带限信号的一种方式。它也可以被视为一种预过滤，即在点采样之前对图案进行模糊处理。 

然而，对于程序纹理模式而言，过采样通常并非最佳选择。如果着色器执行大量计算，为每个像素多次执行该着色器并不是一个好主意。多重采样也无法消除锯齿，只是减轻了锯齿现象，并且质量提升（以与期望值的标准差来表示）仅与采样数量的平方根成正比。这是一种解决办法，但并非理想之选，而且代价高昂。 

![2505024703 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/05/1mg/2505024703-.png) 
*多重采样。左：每像素 2×2 个样本。右：每像素 4×4 个样本。*

正如你在上面的图像中看到的，多重采样确实改善了锯齿边缘。然而，摩尔纹改善得并不多。一些缺陷被推到了更高的频率，但在图案的频率以不可预测的方式与采样频率相互干扰的地方，摩尔纹图案仍然很明显。

另一种隐藏Aliasing的方法是，不对每个像素的精确中心进行采样，而是在像素区域内的一个伪随机点进行采样。这被称为抖动采样，虽然它实际上并不能消除混叠，但它会破坏规则的干涉图案，将规则的阶梯状锯齿和摩尔纹图案转变为细粒度的噪点。对于人类观察者来说，噪点通常比明显的重复图案瑕疵更容易接受。Not always, but usually
![2505025510 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/05/1mg/2505025510-.png)
*抖动采样*

软件渲染器通常采用抖动采样和多重采样的某种组合，通常以自适应方式在物体边缘和高对比度区域执行。在动画中，样本还可以在时间上分布，以模拟运动模糊，减少闪烁和频闪伪影。这被称为分布式采样。GPU渲染可以通过跨帧的多重采样和平均来实现类似的效果，但这需要巨大的计算成本，并且在交互式渲染场景中，很少以自适应方式在特别有问题的像素上投入更多计算量

## 程序性补救手法

幸运的是，对于程序化图案来说，这些解决方法都不需要，因为一个编写良好的程序化着色器（到现在你应该知道这一点了，对吧？）可以自行进行抗锯齿处理。下面的图片就来自一个这样做的着色器。
![2505025529 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/05/1mg/2505025529-.png)
*自适应反走样程序模式。*

白色与黑色之间生硬过渡产生的锯齿边缘，现在通过着色器代码得到了明显的平滑处理。在可能出现摩尔纹的地方，图案会逐渐淡化为其平均颜色，在这种情况下是中灰色。这种抗锯齿处理每个像素仅需一个样本，与本章第一张图片中严重锯齿化的着色器相比，其额外计算成本非常低。这种在着色器内部实现的“智能”抗锯齿通常被称为解析抗锯齿。该术语广泛用于指代由着色器执行的任何一种抗锯齿。这个名称意味着它可能涉及大量数学运算，但在很多情况下它可以相当简单。在这种情况下，它完全是通过上一章提到的“魔术”方法 `aastep` 和 `fwidth`. 

现在是时候解释这些函数的实际工作原理了。

### 自动微分 Auto-derivatives

抗锯齿在着色器中相对容易实现的一个关键原因是，渲染器中存在一个称为自动微分的子系统。它们在软件渲染和硬件渲染中的工作原理大致相同，但我们的解释将侧重于GPU渲染。在GLSL中有两个函数，分别称为$dFdx$和$dFdy$。无论参数多么复杂，它们都会尽力计算参数的偏导数。从函数名中你可能猜到，$dFdx$计算x方向的偏导数，而$dFdy$计算y方向的偏导数。 

现在，着色器函数如何计算任意表达式的导数呢？实际上，它并非对任何东西进行真正的解析求导（符号微分），而是通过有限差分（数值差商）来计算近似值，该差分分别是在当前像素以及x和y方向上相邻像素处表达式的值之间计算得出的。所谓的“导数”实际上只是一次减法运算。 

但等一下！着色器程序甚至不应该知道相邻像素在做什么，更不用说访问它们的结果了吧？嗯，这就是这个特性隐藏在内置函数中的原因。对相邻像素（片段）中相同表达式求值结果的访问是隐式的。渲染算法并行计算多个片段，当在指令流中遇到 “导数” 函数时，参数中表达式的数值会在两个线程之间共享，并计算有限差分。看似神奇的东西，实际上只是在程序员间接请求下，在幕后执行的几次减法运算而已。

> 译者注: 之前看 fwidth的时候花了很久的时间才了解大概，因为学习 GPU编程要做的一个转化是，计算某个像素的时候是无法访问其他像素的信息的。但是这里老师讲的很清楚，GPU藏了一手。

这些有限差分步骤在像素坐标x和y中是沿正方向还是负方向进行的呢？对于那些在该方向上没有运行相同着色器程序的相邻像素该怎么办？更糟糕的是，对于那些根本没有执行相同着色器的相邻像素又该如何处理？这些问题的简短答案是 “**视情况而定**” 和 “**情况很复杂**”。

更详细一点的答案是，一些GPU可以选择设置精确或快速自动求导的偏好，“快速”意味着在两个相邻片段之间共享相同的导数计算结果，这实际上使导数函数的采样率降低为片段分辨率的一半。有些GPU仅采用这种方式，而有些则可以选择使用一致的方向来进行求导计算，但性能会有所下降。至于当没有相邻像素可用于计算导数时GPU会如何处理，当着色器处理孤立像素或渲染为仅一个像素宽的细长物体时，自动求导函数实际上并不能保证返回合理的结果。在这种情况下，结果是 “未定义的”，很可能毫无用处。

由于自动求导的工作方式，仅对两个相邻片段的值进行简单相减，它们只能计算一阶导数。对导数再求导并不能得到二阶导数。调用 `dFdx( dFdx( … ) )` 甚至 `dFdx( dFdy( … ) )` 很可能返回无意义的值或零。虽然语法上形式上是允许的，但结果是 “未定义的”，这意味着你不应该这么做。如果你需要二阶导数，就需要计算函数的解析导数，并在着色器代码中实现。实际上这并不像听起来那么难，而且可能非常有用，但我们这里先不详细讨论。我们将在第11章 “噪声” 中再回过头来讨论它。 

既然我们已经解释了自动求导，那么它们有什么用呢？最常见的用法是间接的，包含在内置函数 `fwidth` 中。在语言规范中，`fwidth` 是根据其等效的 GLSL 代码定义的：

```
float fwidth(float value) {
	return abs( dFdx( value ) ) + abs( dFdy( value ) );
}
```

就是这么简单。这是在屏幕空间（像素）坐标中，参数值的梯度向量长度的近似值。使用两个绝对值来代替两次乘法和一次开方运算去计算二维向量的长度，这一捷径节省了计算量。（在浮点运算中，将两个绝对值相加，除了加法运算本身之外，基本上无需额外操作——你只需忽略两项的符号位即可。）

fwidth进行的“快速而粗略”的长度计算，对于沿x或y方向的梯度是正确的，但在其他方向上会高估其长度，误差高达$\sqrt{2}$倍。在许多情况下，这种误差影响不大。然而，如果你想要更高的精度，你应该考虑实现自己版本的fwidth，如下所示：
```
float better_fwidth(float value) {
	return length( vec2( dFdx( value ), ( dFdy( value ) ) );
}
```

一个性能还算不错的现代图形处理器（GPU）应对这些额外工作毫无问题，并且在一个较为复杂的程序化着色器中，这可能不会大幅增加总工作量。不管怎样,如果你急需时钟周期，并且想要达到绝对的最佳性能，那么内置的 fwidth 函数会很有用，而且通常效果足够好。关于`fwidth`的计算方法就讲到这里。但我们该如何使用它呢？函数名就暗示了最直接的用途：计算合适的 “filter width”。 

就其梯度而言，$\|\nabla F\|=\sqrt{(\partial F / \partial x)^{2}+(\partial F / \partial y)^{2}}$ 表示该表达式在屏幕空间中的变化率。在屏幕空间中沿梯度方向移动一个像素的距离，会使该参数产生相应的变化量。因此，要在由阶跃函数创建的清晰边缘上创建一个像素宽的混合效果，我们应该用在长度为 $\|\nabla F\|$ 的区间内发生的平滑过渡来代替阶跃。这正是OSL中aastep函数的作用。 

> 译者注:  其实就是变化越剧烈，就拿个 smoothstep去抹一下


### Anti-Aliased Step函数
我们在上一章展示了 GLSL 中 aastep 的实现方式，不过我们在这里再重复一遍。
```
// Anti-aliased step function in GLSL
float aastep( float edge, float value ) {
	float w = fwidth( value ) * 0.5; 
	return smoothstep( edge – w, edge + w, value );
}
```
这是一个简单直接的实现，但做一些调整可以让它的表现更好一点。首先，我们对 `fwidth` 的使用使得 `w` 的值具有各向异性——它将取决于梯度的角度。这可以通过实现我们自己的版本来解决，而不使用 “speed cheat”。其次，在使用 `smoothstep` 进行blending时，我们的步长有点太短了。你可能还记得，`smoothstep(a, b, x)` 在 `x = a` 和 `x = b` 处斜率为零。这意味着在两端变化不大，并且在 `a` 和 `b` 的中间，该函数的斜率比线性斜坡更陡。为了解决这个问题，我们可以改用线性斜坡，或者把 `w` 设得更大一些。
在OSL中，有一个函数`linearstep(a, b, x)`，其工作原理与`smoothstep`类似，但在a和b之间有一个从0到1的线性渐变。
![2505021254 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/05/1mg/2505021254-.png)
*The linearstep function*
其他着色语言没有内置的linearstep函数，但自己实现一个很容易。在GLSL中，代码如下：
```
float linearstep( float a, float b, float x ) { 
	float ramp = (x – a) / (b – a); 
	return clamp( ramp, 0.0, 1.0 ); 
}
```

clamp函数在GPU着色中还有许多其他用途，特别是在这种情况下，它将一个值限制在[0,1]范围内。它的功能可以用以下等效代码描述：
```
float clamp( float x, float minval, float maxval ) {
	if( x < minval )
		return minval;
	else if ( x > maxval )
		return maxval;
	else return x;
}
```
这当然可以用三元运算符 `?` 更高效地表达，但GLSL中的 `clamp` 函数很可能是硬件加速的，并且编译器也更容易优化，所以为了速度，你最好使用内置版本，而不是自己编写一个。内置版本还有几个针对向量和整数类型的重载版本，非常方便。


然而，线性渐变 显然并非我们抗锯齿处理的正确选择。在抗锯齿处理中，我们通常努力做到的是让点采样模拟区域采样。我们不希望仅根据 像素中心位于边界内部还是外部来确定像素值，而是希望像素值由落在边界内的像素区域占比是多少， 而求占比其实是一个关于位置与方向的函数。

> 译者注： 点采样是一种在信号处理和计算机图形学中用于确定像素值的方法。从文档内容可知，点采样是指仅依据像素中心的情况来决定整个像素区域的颜色 。在文中提到的图形绘制场景中，比如绘制有倾斜线条和弯曲轮廓的图形时，如果仅使用前景和背景两种颜色，且通过点采样来决定像素颜色，就会出现锯齿状边缘。 区域采样不再像点采样那样仅考虑像素中心这一个点的颜色值来确定整个像素的颜色，而是综合考虑像素区域内多个点或者整个区域的信息。在处理图形边缘时，它会计算像素区域与图形边缘的交集情况，根据交集面积来确定像素颜色。例如在绘制直线或曲线时，一个像素可能部分处于图形内部，部分处于图形外部，区域采样会根据该像素被图形覆盖的比例来混合前景色和背景色，从而得到更平滑过渡的颜色效果

区域采样的近似计算可以通过多种方式实现。一种相当粗略的近似方法是假设像素为具有模糊边缘的圆形。显然并非如此，但从信号处理的角度来看，这是一种先进行低通滤波再进行点采样的方法，而且效果还不错——至少比点采样要好。不过，我们至少可以更深入地研究一下这个问题。 
> 译者注： 低通滤波相当于对将 aliasing 高频混叠部分直接裁剪掉

使用规则的正方形采样区域（这是绝大多数情况下的选择）时，像素区域覆盖一个小正方形。该正方形与一条边的交集（作为边位置的函数）相对容易计算。虽并非易事，但也相对容易。下面的图示展示了三种不同边方向的情况。 
对于轴对齐的边缘，面积覆盖率作为边界位置的函数，是一个宽度为1像素的线性斜坡。然而，对于倾斜的边缘，面积覆盖率在起始和结束时呈现抛物线形状，在端点处斜率逐渐减小至零。对于大多数方向，这看起来更像是一个平滑过渡函数。 
![2505021711 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/05/1mg/2505021711-.png)
*Area coverage as a function of the position of an edge relative to the pixel center.
Left to right: axis-aligned edge, 22.5 degree edge, 45 degree edge.*

> 译者注： 这里表示的是对于不同的角度，命中的面积是不一样的。 具体就是上图下面的曲线。 这些曲线长得比较像 linearstep 和 smoothstep. 所以可以用这两个函数去近似。 

是否使用线性阶跃（linearstep）还是平滑阶跃（smoothstep）在很大程度上取决于个人喜好。当然，我们可以根据梯度的角度计算出更精确的面积覆盖率，但在大多数情况下，这会显得过于繁琐。我们选择使用smoothstep，并使step的宽度略大于渐变。精确的宽度并非至关重要，因为无论如何我们都不是在以精确的方式进行此操作。从形式上来说，即使我们要计算真正的区域覆盖范围，我们也需要考虑边缘两侧的颜色以及显示设备的非线性 “伽马曲线”，以便在边缘处计算出光度学上正确的混合效果。我们将简化处理，仅使用比‖∇F‖宽50% 的步长： 

```
// Better anti-aliased step function in GLSL
float aastep( float edge, float value ) {
	float w = 0.75 * length( vec2( ( dFdx( value ), dFdy( value ) ) ) );
	return smoothstep( edge – w, edge + w, value );
}
```
请注意，我们仍然选择使用真实的、各向同性的梯度长度。内置的 `fwidth` 相当粗糙，而且它节省的执行时间通常微不足道。不过，除非你注意到任何视觉差异，否则你可能更倾向于使用内置版本以获得轻微的加速。
系数0.75并没有什么神奇之处——它只是为smoothstep函数创建了一个斜坡，其宽度是‖∇F‖的1.5倍。对于特定的显示器和特定的图案，你可能希望将该系数稍微调小以创建更清晰的边缘，或者稍微调大以获得更柔和的边缘。用于判断效果好坏的视觉测试用例是具有高对比度的略微倾斜的边缘，如下所示：
![2505022111 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/05/1mg/2505022111-.png)
*Edges using smoothstep with different step widths in proportion to ‖∇ F‖.
From left to right: 0.0, 1.0, 1.5, 2.0, 4.0.*

无论是左极端值还是右极端值都不是好的选择，但在三个中间值中哪个看起来 “最佳” 取决于边缘的斜率和对比度。这在不同的显示设备上也会有所不同，甚至还可能与个人品味和艺术表达有关。1.5 这个系数似乎适用于大多数情况，但不要害怕改变它。这是凭眼力判断，并非精确的数学计算。

关于aastep函数，最后说明一点，无论是OSL中的内置版本，还是我们刚刚在GLSL中自行编写的版本：阈值参数应该是常量，或者至少与要和该阈值比较的值相比变化缓慢。如果两者的变化幅度大致相同，aastep内部的自动求导将无法考虑阈值的变化，并且由于阈值的非零梯度，会导致边缘看起来要么过于锐利，要么过于柔和，而且似乎是随机出现这种情况。如果两个值变化都很快，我们可以计算它们的差值，并与0.0进行阈值比较：
```
edge = aastep( varyingvalue1, varyingvalue2); // Wrong
edge = aastep( 0.0, varyingvalue2-varyingvalue1); // Right
```

使用普通的阶跃函数，上面两行代码会做完全相同的事情，但我们自己实现的aastep函数对两个参数的处理方式不同。当然，我们可以修改`aastep`的实现，改为计算参数之间差值的梯度。只需要将上面额外的减法运算移到函数中：
```
// More robust anti-aliased step function in GLSL
float aastep( float edge, float value ) {
	float F = value – edge;
	float w = 0.75 * length( vec2( ( dFdx( F ), dFdy( F ) ) );
	return smoothstep( – w, w, F );
}
```

仔细查看代码，实际上这比上面的版本工作量稍少，因为额外的减法运算减少了两次加法运算，这些加法运算是用于计算smoothstep函数的参数。在某些情况下，你可能希望使用相同的函数来计算具有不同阈值的多个aastep过渡，在这种情况下，编译器无法通过重用相同的自动求导结果来优化你的代码，但要记住，每次自动求导实际上只是一次减法运算。通常，使用这个修改后的aastep版本，而不是使用要求阈值为常量的版本，并没有明显的缺点。 


### 再看砖块图案

在上一章中，砖块图案的一个遗留问题通过一种映射得以解决，这种映射的创建颇费了一番脑筋。我们还提到，还有另一种更通用的方法来解决这类问题。现在你已经具备了足够的知识来理解如何做到这一点。
让我们回到“砖块”图案的倒数第二个版本，即砖块之间的缝隙落在“三角波”映射的峰值处的那个版本。问题在于，当网格线变得非常细时，会在网格线上出现伪影。出现这种情况是因为自动求导在尖锐的极值附近经常出错，而我们的三角波函数的峰值非常尖锐（峰值处的曲率无穷大）。我们用于渲染砖砌体图案的倒数第二个着色器是：
```
float bricks( vec2 p ) {
	vec2 q = fract( p + vec2( 0.5 * floor( p.y ), 0.0 ) ); // Staggered grid
	q = 2.0 * abs( q – 0.5 ); // Change from sawtooth to triangle
	float brickx = 1.0 – aastep( 0.99, q.x ); // vertical gaps
	float bricky = 1.0 – aastep( 0.98, q.y ); // horizontal gaps
	return min( brickx, bricky ); // If either is 0, return 0
}
```

当砖块之间的间隙变窄时，就会出现伪影。其具体外观取决于自动求导的计算方式，不同平台之间可能会略有差异，但通常看起来是这样的：
![2505022529 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/05/1mg/2505022529-.png)
*Anti-aliasing artifacts at thin lines, due to incorrect auto-derivatives.*

线条中的像素缺失看起来很糟糕，并且它们严重依赖于图案相对于像素网格的确切位置，也就是说当图像动起来的时候，他会发生闪烁现象。这里的问题是，我们要求aastep在非常接近三角波峰值的位置计算其自动导数。从一维角度看，很容易明白哪里出了问题。 下面的图也展示了完全不连续的情况，以证明我们通过使用连续映射函数已经避免了一些重大误差。

> 译者注：这种情况可以访问  https://www.shadertoy.com/view/332Xzy

![2505022612 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/05/1mg/2505022612-.png)
*Auto-derivative at x (green circle) computed as finite difference in fragment space.*
*左：正确的结果。中：估计的斜率太小，产生不正确的 AA。右：在不连续性处，AA太大。*

为了使抗锯齿起作用，我们需要的是即使在峰值附近也能得到正确的导数。我们只需要梯度的长度，这只取决于偏导数的绝对值，而对于这个映射，这些偏导数在任何地方实际上都是常数。三角波的斜坡具有正负交替的斜率，但绝对变化率在任何地方都是相同的。此外，这个常数导数与原始映射坐标的导数相同，也就是我们在为网格创建局部坐标之前所使用的坐标。嗯，几乎相同——我们将函数缩放了2.0倍，这意味着我们也缩放了它的导数。 
利用这些信息，我们可以将抗锯齿函数`aastep`的代码插入着色器中，并对其进行修改，以便根据未经修改的映射坐标计算步长。我们还可以实现该函数的一种“修改版”，即提供一个单独的函数来计算导数。不管哪种方式都有点“取巧”，但“修改版`aastep`”的方法使着色器代码不那么杂乱，并为我们提供了一个可复用的辅助函数：
```
// Hacked aastep function to compute correct derivatives at problematic points
float aaxstep( float threshold, float value, float value_for_fwidth ) {
	float w = fwidth( value_for_fwidth );
	return smoothstep( threshold - w, threshold + w, value );
}
```
使用这个修改后的函数，着色器代码将为：
```
// Brick pattern that antialiases correctly even when the gaps are very thin
float nicebricks( vec2 p ) {
	vec2 q = fract( p + vec2( 0.5 * floor( p.y ), 0.0 ) ); // Staggered grid
	q = 2.0 * abs( q - 0.5 ); // Change from sawtooth to triangle
	float brickx = 1.0 - aaxstep( 0.995, q.x, 2.0*p.x ); // vertical gaps
	float bricky = 1.0 - aaxstep( 0.99, q.y, 2.0*p.y ); // horizontal gaps
	return min( brickx, bricky ); // If either is 0, return 0
}
```
我们本可以通过将q限制在[0, 0.5]范围内并调整阈值来避免三次乘以2.0的操作，但这也不是什么大问题。让每个网格单元的局部映射范围为[0, 1]会很方便。还要记住，在浮点运算中，乘以2仅仅意味着将指数加1。

现在，即使砖块之间的缝隙变得小于一个像素，这个着色器的表现仍然相当不错。不幸的是，当线条宽度明显小于一个像素时，它们并不会逐渐消失，这无疑是该着色器仍然存在的一个缺陷。我们可以解决这个问题，那就动手吧！

还记得网格线示例中的“双边”阈值化方法吗？这是一种让极细线条消失的好方法。我们所做的是取两个smoothstep之间的差值，这两个smoothstep s上下界相同，但相互错开。当它们相距较远时，结果很明显：我们得到一个上升斜坡和一个下降斜坡，中间有一个平台。然而，当它们靠近时，结果就不同了：我们得到一个较低的峰值，但其波的横向范围或多或少保持不变。 
![2505033051 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/05/1mg/2505033051-.png)
*Green and red lines: two smoothstep ramps of the same slope and decreasing
offset. Black line: the difference between them (green minus red).*

当两个平滑斜坡非常靠近时，它们差异的空间范围几乎保持不变（其步长加上小偏移量），但其幅度会随着偏移距离线性下降。这类似于我们对穿过像素内任意位置的极细线条进行区域采样时得到的结果边界。它并不完全准确，但通过为两个平滑渐变精心调整步长，对于大多数用途来说已经足够好了。使用这种技术，非常细的线条会随着距离自动淡出并融入背景。此外，线条随距离的淡出效果是由渲染线条的相同函数中实现的，这很方便。

> 译者注：这块我理解起来有点困难， 这里在远处并不是像素平均，而是采样。

考虑到我们现在也制作了aastep的“防故障”版本，在这个版本中，我们可以为导数计算提供一个连续函数，但在阈值处理时使用任何具有相同局部斜率的函数，实际上我们可以完全回到具有单向斜率的原始分形坐标，并围绕这些斜坡的中点0.5对称地执行阈值处理：

```
float verynicebricks( vec2 p ) {
	vec2 q = fract( p + vec2( 0.5 * floor( p.y ), 0.5 ) ); // Staggered grid
	float gw2 = 0.005; // Gap width/2, relative to brick height
	float brickx = aaxstep( 0.5-gw2, q.x, p.x ) - aaxstep( 0.5+gw2, q.x, p.x );
	float bricky = aaxstep( 0.5-gw2, q.y, p.y ) - aaxstep( 0.5+gw2, q.y, p.y );
	return max( brickx, bricky ); // If either is 1, return 1
}
```

![2505033203 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/05/1mg/2505033203-.png)
*Left: badly aliasing bricks. Right: Our now quite robustly anti-aliased bricks.*

> 译者注： 这块的效果可以参考译者按照文章写的 https://www.shadertoy.com/view/w3jSzy

在尝试使用着色器时，常常感觉进展不大。在这种情况下，将当前的成果与几小时前或昨天的成果进行比较，通常会是一次有益的体验。过程中的进展可能很小，但随着时间的推移，它们会积累起来。无论如何，最好至少保存一些你在过程中进行的多次迭代成果，因为有时候当你迷失方向、发现自己陷入死胡同，或者想到了更好的解决方案时，能够轻松回溯是一件很不错的事情。

仔细观察代码，我们实际上是在指示GPU对2.0*p.x和2.0*p.y进行两次自动求导——每次将它们作为最后一个参数调用aaxstep时都会进行一次。由于函数在GLSL中会被内联，我们可以合理地假设，这个重复的表达式会被编译器捕获，并且在生成的代码中每个导数只计算一次。如果不是这种情况，请记住，自动求导实际上只是一次减法运算，它涉及的额外处理非常少。这里的大部分工作都集中在四个smoothstep渐变函数上。 

这部分内容有一个寓意。在完全不考虑抗锯齿的情况下，创建某种图案可能很容易。而采用适当且强大的抗锯齿技术时，通常就不那么容易创建了。然而，这并非无计可施，只是需要更多的思考和一些测试。如前所述，如果过程式着色器能正确实现解析抗锯齿，它会有用得多，所以这始终是首选。通过后期处理进行抗锯齿会给渲染器带来更多工作，而且在某些情况下，后期无法补救。通过多重采样可以在一定程度上较好地平滑锯齿边缘，但代价相当大，而摩尔纹和闪烁在后期处理中几乎不可能消除。 

最后需要说明的是，尽管我们的大多数示例都集中在GLSL和GPU着色上，但值得一提的是，软件着色语言OSL的内置aastep函数有多种变体，允许你为参数提供自己的解析导数。这个特性的存在是有原因的。与锯齿相关的问题以及许多消除锯齿的优秀解决方案在软件着色中是众所周知的，在硬件着色中也同样值得关注。软件着色器程序员已经摸索了几十年，在编写GPU着色器时，在适用的情况下，借鉴他们的经验是明智之举。 

### 频率夹子 Frequency clamping

到目前为止，我们一直将抗锯齿工作集中在边缘上，使其平滑而不是锯齿状。另一种混叠现象是本章开头对图像具有极大破坏性的摩尔纹。诚然，那个测试图案是专门为产生摩尔纹而制作的，但它并非不能代表真实场景。表面着色器应允许在任何距离下进行观察。在一定距离处，重复图案的周期会接近像素分辨率，超过这个距离就必须采取措施来避免摩尔纹类型的混叠。 

在基于图像的纹理映射中，这个问题通常通过一种称为mip映射的方法来处理，该方法包括对每个纹理图像进行下采样，以连续降低分辨率。这可以在上传之前预先完成，也可以在纹理上传期间由GPU硬件辅助完成。然而，纹理金字塔映射需要滤波，而滤波需要访问图案中的相邻点。纹理金字塔堆栈的顶层是图像中所有像素的平均颜色。程序化着色器无法采用这种方法，因为纹理不是完整计算的，而且通常不是在规则间隔的采样点上计算的。碰巧计算出的样本甚至不会作为单独的数据集存储。 
这并不一定是个缺点。在程序化着色器中，我们可以完全避免生成频率过高的图案，而是用图案的平均值取而代之。就像边缘抗锯齿一样，这可以被视为对区域采样结果的模拟。实际上，对于周期性图案来说，这样做甚至更好，因为当采样频率接近图案频率的一半，即接近“奈奎斯特极限”时，区域采样仍然会出现干涉问题，从而产生摩尔纹。 

#### 像素的大小
为了确定在正在渲染的图像中我们能够分辨出多小的细节，我们需要知道像素样本之间的距离。这可以通过跟踪所有变换并考虑视口分辨率来实现，但自动求导使这一过程变得容易得多。对于二维表面映射（s, t），我们需要计算四个偏导数：∂s/∂x、∂s/∂y、∂t /∂x 和 ∂t /∂y。在着色器空间中，“像素大小”的第一个近似值可以是这四个偏导数的最大绝对值，或者是以它们为分量的四维向量的长度。这两种方法都不准确，但都足够好了。
```
// Anti-aliased checkerboard pattern with frequency clamping
float clampedcheckers( vec2 p ) {
vec2 ramps = 2.0 * abs( fract( p ) - 0.5); // “Triangle waves”
vec2 stripes = aastep( vec2(0.5, 0.5), ramps ); // 50% stripes
float aacheckers = abs( stripes.x - stripes.y ); // “XOR” for overlaps
// Frequency clamping to handle extreme minification
vec4 diff = vec4( dFdx(p), dFdy(p) ); // Four derivatives in total
float pitch = length(diff); // Roughly the pixel size in p space
// A smoothstep with these bounds looks good in this particular case.
return mix(aacheckers, 0.5, smoothstep(0.2, 0.35, pitch));
}
```
请注意嵌套的max函数——GLSL一次只能选择两个值中的最大值。OSL有一个max函数，它可以接受任意数量的参数并一次性返回最大值，但内置的GLSL版本映射到硬件加速的“比较并选择”指令，并且只接受两个参数。
使用这种在着色器空间中对像素大小的近似粗略度量，我们可以检查即将生成的周期性图案是否会违反采样定理并导致混叠。如果图案的周期小于像素大小的两倍（两者均在着色器空间中测量），就会出现这种情况。如果是这样，我们就不生成该图案，而是用其平均值代替。 

让我们用上一章的棋盘图案来试试这个！

![2505033653 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/05/1mg/2505033653-.png)
*Left: checkered pattern with soft edges only. Right: Frequency clamping added.*

如何确定渐变区域的范围和斜率并非一门精确的科学。要确定对人类观察者来说 “看起来不错” 的效果，通常需要反复试验。我们想要的是在避免出现明显且烦人的摩尔纹的同时，尽可能长时间地保持图案的可见性。渐变速度不应过慢。通过对边缘进行适当的抗锯齿处理，摩尔纹首次出现时的图案频率仅略低于对渲染造成严重破坏的频率。这不是一种微妙的效果，它不会逐渐悄然而至，而是在某个点突然出现。要以一种足够谨慎的方式消除它似乎很困难，但请记住，这是最终图像像素表示所固有的、不可避免的限制。如果图案的细节过小，采样无法处理，就根本无法使图案呈现得很好，这些细节需要从画面中去除。（此处有双关之意 —— 我一点也不觉得不好意思。） 

### 高效 LOD

Frequency clamping方法可以与几何模型的细节层次（LOD）策略相比较。如果在渲染时我们知道某个内容不可见，甚至会扰乱视图，我们就会选择该内容的另一个渲染效果更好、可能所需工作量更少的版本。现在，我们的着色器版本将Frequency clamping作为最后一步，在我们缩小视图时将图案淡化为一种纯色。只要我们还能看到图案的任何部分，这样做就没有问题，但一旦我们到达淡入淡出曲线的终点，我们就会花费大量精力来计算一个程序生成的图案，然后该图案乘以零，永远不会显示出来。这是一种浪费。如果我们能进行一个“提前退出”测试，并且如果表面距离太远以至于其图案不可见，就直接返回常量值，那就更好了。一开始一个简单的if - else条件语句就能为我们做到这一点。现在，GPU着色器以大规模并行单指令多数据（SIMD）的方式执行，传统的“普遍认知”是假设内核中的所有线程都在执行两个分支。更准确地说，两个分支的指令流会广播到所有线程，然后它们选择忽略其中一个分支。然而，许多现代GPU都有一个非常实用但常常被忽视的特性，即如果整个内核（一组使用相同着色器渲染一小片像素区域的核心）的所有核心在if - else分支中都决定选择同一个分支，那么不需要的分支的指令流将不会被发送。并非所有的GPU（目前）都有这个特性，但性能更强的桌面级GPU型号有。 

如果我们将一些Frequency Clamping计算移到着色器的开头，那么在具有该模式的大片连续区域因频率限制而消失的情况下，我们至少可以让着色器执行得更快。
```
// Anti-aliased checkerboard pattern with early-out frequency clamping
float clampedcheckers( vec2 p ) {
	vec4 diff = vec4( dFdx(p), dFdy(p) ); // Four partial derivatives
	float pitch = length(diff); // Roughly the pixel size in p space
	if( pitch > 0.35 ) return 0.5; // Save some work if we’re far, far away
	else {
		vec2 ramps = 2.0 * abs( fract( p ) - 0.5); // “Triangle waves”
		vec2 stripes = aastep( vec2(0.5, 0.5), ramps ); // 50% stripes
		float aacheckers = abs( stripes.x - stripes.y ); // “XOR” for overlaps
		return mix(aacheckers, 0.5, smoothstep(0.2, 0.35, pitch));
	}
}
```

这个特定的着色器很简单，因此它可能不会从提前退出测试中获得很大好处，但对于更复杂的图案，它可以节省大量不必要的工作。

### 各向异性抗锯齿Anisotropic anti-aliasing

周期性图案通常是一维的，但是在不同方向上具有不同的周期的这种情况下，我们可以做得更好，而不是粗略估计像素的平均大小并去除所有可能导致莫尔条纹的频率。因为我们处理的是三维图形，而且我们通常是从倾斜角度而非正面去观察表面。这样除了会带来因透视产生的缩放外，还会在视图投影中导致foreshortening，如果表面上一维图案的主要变化轴受到影响，它们看起来会更加密集。透视缩短的程度可能任意大，所以提前以一定安全余量消除图案甚至都不会起作用。 
关键在于以其原本的意图来使用偏导数：计算屏幕空间中曲面上向量的长度。如果图案是沿某个特定方向的波，我们可以在该方向上构造一个长度为图案周期的向量，将其转换到设备空间，然后检查它是否太短而无法正确渲染。或者，我们可以直接采用自动求导提供的捷径，直接在设备空间中计算周期函数自变量的梯度，可能还需要根据我们所使用函数的波长进行调整。（这就是为什么在局部坐标映射中使用周期为1.0的函数通常是个好主意。） 

局部一维模式的Frequency clamping可以这样进行：
```
float clampedbullseye( vec2 p ) {
	p *= vec2(0.5, 1.2); // Scale differently in x and y
	float r = 4.0 * (length(p) – 0.5); // Radial distance
	// Linear increase near center, exponential increase further away
	float rf = (r < 0.0 ? r + 1.0 : pow( 2.81828, r ) );
	float circles = aastep(0.25, abs( fract( rf ) - 0.5 ) ); // Concentric circles
	float fw = length(vec2(dFdx(rf), dFdy(rf))); // isotropic fwidth(rf)
	// Frequency clamping
	float fade = smoothstep(0.2, 0.3, fw);
	return mix(circles, 0.5, fade); // Fade to constant 0.5 when clamping
}
```
我们之前使用过这种测试图案，但没有给出其代码。在下一页顶部会再次展示该图案。该图案是二维的，但局部来看，它在各个方向上都是一维条纹图案。请注意，Frequency clamping取决于片段空间中的图案频率，因此各向异性缩放会导致在拉伸的x方向上渲染出更多条纹。 
在基于图像的纹理映射中，各向异性抗锯齿是一个难题，需要进行多重采样，即使在现代图形处理器（GPU）中也未能完全令人满意地解决。而使用程序化纹理，各向异性抗锯齿则可以变得容易。
![2505034514 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/05/1mg/2505034514-.png)
*Ellipses with direction-dependent (anisotropic) frequency clamping.*

###  雅可比矩阵 The Jacobian matrix

对着色器坐标与像素大小之间关系更正式的处理方法是，使用偏导数来创建变换的局部雅可比矩阵的有限差分近似。然后，这个2×2矩阵可用于将方向向量从着色器空间（当前表面的纹理映射坐标）变换到设备空间（当前视图中的像素坐标）。

![2505034640 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/05/1mg/2505034640-.png)
*Local surface coordinates (s,t) in relation to fragment coordinates ( x , y).*

```
// st is a vec2 of texcoords , G2_st is a vec2 in texcoord space
mat2 Jacobian2 = mat2 ( dFdx (st), dFdy (st));
// G2_xy is G2_st transformed to fragment space
vec2 G2_xy = Jacobian2 * G2_st ;
// stp is a vec3 of texcoords , G3_stp is a vec3 in texcoord space
mat2x3 Jacobian3 = mat2x3 ( dFdx (stp), dFdy ( stp ));
// G3_xy is G3_stp projected to fragment space
vec2 G3_xy = Jacobian3 * G3_stp ;
```

Transforming a vector in (s, t) or (s, t, p) texture space to fragment (x, y) space.
通常，不需要使用完整雅可比矩阵进行变换，因为自动求导可用于隐式执行相关计算，而且工作量往往更少。不过，了解到可以构建变换到片段空间的局部雅可比矩阵并将其用于解析抗锯齿是很有用的。在某些情况下，这可能是最佳解决方案。 
