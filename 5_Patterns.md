# 周期性重复图案的生成与优化

我们周围世界的大多数表面都有图案，这可能是制作工艺使然，也可能是为了美观而进行的装饰。本章主要讨论重复图案，比如条纹、平铺图案、机织或针织织物图案、网格、波点和方格图案等等。现实世界中，非重复的随机或类似随机的图案也很常见，不过从第10章“噪点”开始，我们再讨论这些图案。

## 一维周期性重复模式

当你想到周期函数时，首先想到的可能是正弦函数和余弦函数。由于它们在计算机图形学中具有重要作用，这两个函数在所有着色语言中都是内置函数。在现代GPU中，它们很可能会得到高度加速，我们当然可以用它们来生成图案。

条纹图案可以通过对正弦函数应用阶跃函数来创建。假设x是曲面的映射坐标之一，我们可以这样写：
```glsl
float stripes = step(0.0, sin(x));
```
这将创建一个垂直于x方向的条纹图案，变量条纹在0和1之间交替，每 $2\pi$ 个单位有一条条纹。将阶跃函数的阈值从0.0更改为-1.0到1.0之间的任何值，都会改变“0”条纹与“1”条纹的相对宽度，而缩放正弦函数的自变量会改变条纹之间的距离：将其缩放因子大于1会使条纹靠得更近，而缩放因子小于1会使条纹分得更开。

然而，使用正弦函数来制作简单条纹有几个缺点。首先，它的周期是 $2\pi$ ，这是一个相当不方便的无理数，而我们通常希望创建周期为某个整数的图案，比如1.0或0.25。其次，阈值与“0”和“1”条纹的相对宽度之间的关系很复杂。当阈值为0.0时，条纹之间的比例为1:1，但如果我们将阈值更改为比如说0.1，要算出比例会是多少，以及确定能给出特定条纹比例（如“0”占30%、“1”占70%）的阈值，都需要一些数学运算。第三，即使通常有硬件加速，计算正弦函数也过于繁琐。我们在这三个方面都可以做得更好。

一个更直接的周期函数是内置函数`fract`（在最早的两种GPU着色语言HLSL和Cg中，它被称为`frac`）。它取一个数的小数部分，这当然会以整数间隔重复。其定义和图像如下所示。
![2504281622](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/02/1mg/2504281622-.png)

请注意，对于参数的负值和正值，该函数都具有相同的正斜率锯齿形状。当前所有着色语言（但并非所有其他提供“小数部分”函数的语言和库都一定如此）中该函数的定义正是如此，仅仅是因为它是用于图案生成最有用的版本。周期性图案不应在映射坐标的任意符号变化时改变其外观——当越过原点时，它应只是以相同的方式继续重复。使用`fract`函数创建条纹图案的一种简单方法是：
![2504281713](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/02/1mg/2504281713-.png)
*A better “stripes” pattern, as code and rendered to a black and white image.*

然而，仍然存在一个缺陷，它与抗锯齿有关。在阶跃函数作用于`fract`函数的上升斜坡处，抗锯齿很容易实现，但`fract`函数在每个整数位置都有一个不连续性，而不连续性极易产生锯齿。`smoothstep`函数无法平滑整数位置处的硬边，所以我们在第4章提到的`aastep`函数在这里不起作用。我们更希望输入到阶跃函数中的内容没有任何不连续性，比如正弦函数，同时在各处都有一个良好的线性斜坡。我们想要的不是锯齿波，而是一个上下都有线性斜率的三角波。生成三角波最有效的方法是采用下面展示的技巧。乍看之下，它的工作原理并非一目了然，但如果你逐步绘制过程，就会清晰明了。

![2504281853](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/02/1mg/2504281853-.png)
*A triangle wave function created from fract (and each step along the way).*

这个三角形函数所需的计算量仅比分形函数略多一些，并且通过抗锯齿的`aastep`函数处理，可以为每个条纹的两条边提供适当的抗锯齿效果。用着色器代码表示，该函数如下：
![2504281958](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/02/1mg/2504281958-.png)
*The triangle-wave function, as code and rendered to a grayscale image.*

这在当前任何一种着色语言中都不是内置函数，但按照此处所示的方式，使用`fract`来创建这个函数很简单，而且它非常有用。

使用`triangle`函数创建条纹与使用`fract`函数一样简单：
![2504282117](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/02/1mg/2504282117-.png)
*Well-behaved stripes (suitable for anti-aliasing) created with the triangle function. Note that both edges of the stripes move when the threshold is changed.*

另一个可用于创建周期性模式的函数是`mod`函数，它在GLSL和OSL中都命名为`mod`。
![2504282215](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/02/1mg/2504282215-.png)
*The modulo function, in its correct interpretation.*
这里展示的函数是模运算在数学上正确的定义，它是用于创建周期性图案的有用版本。不幸的是，包括一些着色语言在内的许多编程语言都有不正确的实现。对于如何对负数正确执行模运算似乎存在很大的混淆，而且存在许多有缺陷的模函数。向下取整函数不太容易被误解，并且通常实现正确，从这个函数出发，你可以重新定义`fract`函数和`mod`函数，使其按预期工作：
```glsl
// The fract function defined correctly in terms of the floor function
float correct_fract( float x ) {
    return x - floor(x);
}
// The mod function correctly defined in terms of the fract function
float correct_mod( float x, float a ) {
    return a * correct_fract( x / a );
}
```

如果你对某种具有这些函数的语言如何实现它们有疑问，那就测试一下，如果有必要，重新实现它们。GLSL和OSL做得对，但WGSL的`modf`函数就实现错了。这不是一个错误，而是（糟糕的）设计使然，而且不太可能改变。用于“除法余数”的%运算符在不同语言中有不同含义，乱得一塌糊涂，所以使用时要小心。

### 优化

请注意，取模运算涉及除法，计算起来比`fract`要多费些功夫。如果`a`是一个常量，着色器编译器应该能够在上述代码中发现这一点，并将除法`(x / a)`替换为在编译时计算出的`a`的倒数与`x`的乘法，即 $x*(1.0 / a)$ 。然而，如果你使用内置函数，情况不一定如此。如果你想要一个具有恒定周期的取模运算，自己创建一个运算，在除法中使用一个显式常量而不是变量作为分母，可能仍然是个更好的主意。这样很可能会被编译器捕捉到并替换为乘法，即使是相当低级的编译器也能做到。如果你要绝对确保这一点，可以在源代码中把比如`x / 4.0`替换为`x * (1.0 / 4.0)`，甚至自己进行数学运算，写成`x * 0.25`，但如今很少有必要做到这种极端的“喂饭式”操作。就在十年前，在这方面情况还有所不同，但现在即使是GPU着色器的即时编译器，也更擅长自行进行此类加速优化。具体来说，对于现代GLSL编译器，`mod(x, a)`中`a`如果是像`43.0`这样的字面常量，或者是`const float`类型，编译生成的代码似乎比完全通用的`mod`运算要快。（你可能需要自己验证一下，而不是只听我们说，因为这些情况变化很快，而且不同平台之间差异很大。）

为了结束这段对编译器技术的小插曲，我们应该提到，着色器编译器的制造商通常不会向终端用户提供优化细节，并且不能保证一个版本的编译器所执行的优化在所有未来版本中也会执行。有时，完全不清楚为什么某种代码变体比另一种更快。

如果有疑问，不要专注于性能，而是要专注于编写能正常运行且可读的代码。GPU的速度会不断提升。为实现合理的速度而编写代码是GPU着色器编程的一个重要方面，但为追求绝对最优速度而编写代码往往徒劳无功。

## 二维周期性重复模式

一维周期性图案在现实世界中很常见，因此作为程序化图案非常有用，但我们当然也希望创建二维周期性图案。二维周期性图案的核心是平面的平铺，其中平面上许多形状相同的小区域都有自己的局部映射坐标。

### 矩形平铺
最常见的 2-D 平铺类型是矩形平铺：
![2504283022](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/02/1mg/2504283022-.png)

在这个例子中， $(s, t)$ 局部坐标分别在范围 $[0, a]$ 和 $[0, b]$ 内。另一种（通常更好的）映射方式是将局部坐标缩放并可能进行平移，使其归一化到像 $[0, 1]$ 或 $[-1, 1]$ 这样的范围。这取决于你想要做什么。是使用取模运算来进行坐标环绕，还是在坐标预缩放后使用小数部分函数，很大程度上取决于个人偏好。

### 波点

现在，让我们使用平铺坐标来创建一些图案！波尔卡圆点图案的创建方式与我们之前绘制圆形的方式完全相同，但使用局部平铺坐标来确定距当前网格单元中心的距离：
```glsl
// Polka-dot pattern in a square tiling.
// The range of R is 0.0 (no dots) to $\frac{1}{\sqrt{2}}$ (no gaps).
float polkadots( vec2 p, float R ) {
    return 1.0 - step( R, length( fract( p ) - vec2 ( 0.5, 0.5) ) );
}
```
“哇，等等”，你可能会说，而且理由很充分。这个函数只用一行代码就完成了所有工作。着色器编程是一个创造性的、反复迭代的过程，通常需要大量的试验和快速修改，这往往会让人们写出这种“一行式代码”。然而，让代码保持这种状态是个坏习惯，会让人难以理解——过一段时间后，就连编写代码的人自己也会觉得难懂——因此也难以维护。为了提高可读性，我们把计算过程拆分成几行，并使用额外的变量来存储中间结果。即使是非常蹩脚的编译器也会优化掉这些变量，生成完全相同的代码，因为在机器码层面，变量根本没有名字。一切都只是存储在寄存器中的值。
![2504283231](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/02/1mg/2504283231-.png)
*Polka-dot pattern in readable code, and a visual example with some color added.*

请注意，将代码拆分成多行是如何让编写详细注释成为可能的，并且现在即使没有注释，代码也更容易阅读和理解。尽量抵制编写“巧妙”的单行代码的诱惑。那样的话，你的代码会变得难以理解，甚至对你自己来说也是如此，而且那样编程没有任何实际用处。毫无用处。说真的。

### 棋盘
一种常用的模式，常被作为程序纹理的示例，即棋盘格模式，它由两种交替颜色的方形区域组成。这种模式在人类文化中极为常见，因为我们喜欢尽可能在各处添加刻意的装饰，让事物看起来赏心悦目。在瓷砖铺设中，如果瓷砖至少有两种对比色，就可以创造出更具视觉趣味的图案。其极端形式是像素风格的图像马赛克，但我们暂且保持简单，仅为网格单元分配交替颜色。实现此功能的一段看似简洁却也有些简单的代码片段如下：
![2504283431](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/02/1mg/2504283431-.png)
*Checkerboard pattern done wrong (read on to learn why).*

这也差点就成了一条“巧妙的单行代码”，所以让我们把它拆开并添加注释，至少为了本次演示需要这样做：
```glsl
float checkers (vec2 p ) {
    float steps = floor( p.x ) + floor( p.y ); // Stair-steps, integer-valued
    return mod( steps, 2.0 ); // Wraps all integers to only 0.0 and 1.0
}
```
将x和y的阶梯式楼层版本相加后，当沿着x或y方向从一个单元格移动到下一个单元格时，总和会增加或减少1。沿对角线移动时，总和要么增加或减少2，要么保持不变。对该总和进行模2运算，所有偶数将变为0，奇数将变为1。沿着x或y方向移动时，当我们跨越图块边界时，输出值会在0.0和1.0之间变化，但当我们沿对角线跨越图块角时，输出值不会改变。这正是我们想要的，对吧？

除了一件重要的事：抗锯齿。只要该图案与输出设备的像素网格对齐，上述图案看起来就没问题，但任何旋转——**尤其是微小的旋转**——任何相机移动、透视效果或几乎任何类型的动画，都会使图案看起来极其糟糕。就目前的形式而言，该函数对于直接生成图案基本上毫无用处。我们需要做得更好。

### 抗锯齿的棋盘

上述棋盘图案的根本问题在于向下取整函数所产生的不连续性。我们不能直接使用该函数的输出结果来绘制图案，因为边缘会产生严重的走样。相反，我们需要创建一个在x和y方向上都有平滑渐变的函数，并使用阶跃函数对这些渐变进行阈值处理，以生成最终的边缘。

借鉴之前的经验（没错，这里是双关语），我们已经有了一种制作抗锯齿条纹的方法，并且我们可以创建一组沿x方向的条纹，以及另一组沿y方向的条纹。为了创建一个棋盘格图案，我们随后需要将这两组条纹叠加，并执行一种“异或”遮罩操作在它们之间进行某种运算，使两条条纹交叉的区域取值为0。在此不详细解释为什么这是一种好方法，或者最初是如何想到这种方法的，简单来说，取垂直条纹和水平条纹之间差值的绝对值就能达到这个效果，并且还能保留由抗锯齿产生的任何平滑边缘：
```glsl
float aacheckers (vec2 p ) {
    vec2 ramps = 2.0 * abs( fract( p ) - 0.5); // “Triangle waves” in x & y
    vec2 stripes = step( vec2(0.5, 0.5), ramps ); // 50% stripes
    return abs( stripes.x - stripes.y ); // “XOR” at overlaps, preserving AA
}
```
这种棋盘图案是通过对无间断的底层函数进行阈值处理生成的，通过将步长更改为其抗锯齿变体（无论是内置的`aastep`函数还是您自己提供的函数），都能实现良好的抗锯齿效果。

![2504283717](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/02/1mg/2504283717-.png)
*Checkerboard pattern, without antialiasing (left) and with anti-aliasing (right).*

请注意，阶跃函数的任意一个阈值都可以更改，以使图案呈现出更多样化的不同外观。
![2504283826](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/02/1mg/2504283826-.png)
*Variations on the checkerboard pattern.*

既然你已经知道如何实现一种可以抗锯齿的棋盘格图案，那么除非你确定不需要抗锯齿，否则请不要使用原始的"floor-mod”版本。它代码简单，容易记住，而且速度快，但对于大多数用途来说，它就是不好。

### 抗锯齿的网格线
网格线是一种非常常见的图案，不仅在图表和抽象绘画中，在现实世界场景中也很常见，比如瓷砖铺设。格子图案是人类文化中一种非常常见的装饰元素，它也可以由交叉条纹组成。
很容易想到以如下方式编写一个用于跨越 $(x, y)$ 网格线的函数，因为它只需要一次分数运算和一次步长运算：
![2504283948](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/02/1mg/2504283948-.png)
*Grid lines coded in a naive manner, and a visual example.*

然而，这会在不连续处，即网格单元边界处，产生特别严重的走样现象。网格映射中的不连续性不一定总是坏事，但图案中的边缘不应与它们对齐。（绝对不要。说真的。）相反，我们应该为每条线使用两个阶跃函数：
```glsl
float gridlines( vec2 p ) {
    vec2 q = fract( p ); // Square grid of size 1x1 
    vec2 grid = step( 0.45, q ) - step( 0.55, q ); // Both edges are explicit
    return max ( grid.x, grid.y ); // Overlay the two sets of crossing lines
}
```

在这两种情况下（除了平移）模式是相同的，但当你尝试通过将`step`替换为`aastep`来对网格线进行抗锯齿处理时，“快速简便”的版本无法让你平滑处理网格坐标从1跳回0时的隐式边缘。到目前为止，通过对每条边使用一个`step`函数来使两条边显式。要知道走样严重的图案远不如能够自行抗锯齿处理的图案有用。
![2504284252](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/02/1mg/2504284252-.png)
*Left: Badly aliasing rotated grid. Center: Failed anti-aliasing by the naive code. Right: Mostly successful anti-aliasing by the improved code. Inset: see text.*
> 译者注： 在m3芯片  macbook pro chrome浏览器上并未发现伪影

仔细观察上面最右边的图像，改进版本的线条边缘很平滑，但在我们发送给`aastep`函数的坐标不连续处，线条之间的方块中可以看到淡淡的十字状伪影。插图中展示了增强对比度后的视图。出现这种情况是因为`aastep`函数在不连续处未能计算出合适的步长。（下一章将给出对此的完整解释。）为了消除这些伪影，我们可以格外小心地处理图案的那些部分，或尝试以某种方式提高`aastep`函数的性能。这两种方法都是完全可行的解决方案。不过，我们也可以记住从棋盘图案中吸取的教训，使用“triangle”函数
```glsl
// A pattern of (x,y) grid lines, done right
float aagridlines ( vec2 p ) {
    vec2 ramps = 2.0 * abs( fract( p ) - 0.5); // “Triangle waves” in x and y
    vec2 lines = aastep( 0.45, ramps ) - aastep( 0.55, ramps); // 0.1 wide
    return max( lines.x, lines.y ); // Overlap the two sets of lines
}
```

这段代码的结果看起来与上面最右边的图像相同，只是没有那些模糊的伪影。我们解决了这个问题，而且计算成本非常低。由于我们生成三角波的方式，现在网格线的密度翻倍，网格间距为0.5个单位，但这可以通过简单缩放p来调整。

现在，通过编写`aastep(0.05, abs(ramps - 0.5))`，在`abs`之后使用单个`aastep`，我们难道不能解决问题吗？嗯，我们可以这么做，但对于细线来说效果并不好。对于这种模式的预期用途，网格线的两条边缘在屏幕坐标中通常会非常接近：彼此相距在单个像素内，甚至会穿过同一个像素。三角形函数的阈值会接近0.0或1.0，并且使用`aastep`进行抗锯齿在三角形函数的尖锐端点附近会出现问题。单个阈值在制作相当宽的条纹表现不错，但上面带有两个阈值的代码更适合绘制细线。这背后的原因将在下一章中阐明，不过在此之前，“相信我，我是专业的。”

### 交错平铺
矩形平铺的变体包括斜铺，即平铺的图形不是矩形而是平行四边形；还有交错平铺，即相邻的矩形行或列相互错开。斜铺将在“噪声”一章中讨论，所以我们先把它留到后面，这里只讨论交错平铺。有许多现实世界中交错平铺的例子，比如砌砖和地砖
![2505021420](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/02/1mg/2505021420-.png)

#### 砖砌图案
错列铺贴用于砌砖工程，而砖墙图案是程序化着色器的经典示例，所以在继续之前，我们先在这里展示一下该图案。我们将砖块的值设为1.0，砖块之间的灰浆值设为0.0：
```glsl
float bricks( vec2 p ) {
    vec2 q = fract( p + vec2( 0.5 * floor( p.y ), 0.0 ) ); // Staggered grid
    float brickx = step( 0.1, q.x ) - step( 0.9, q.x ); // vertical gaps 
    float bricky = step( 0.1, q.y ) - step( 0.9, q.y ); // horizontal gaps
    return min( brickx, bricky ); // If either is 0, return 0
}
```
同样，这第一次尝试在抗锯齿方面表现不佳，因为我们通过`step`函数传递的函数存在不连续性。我们并没有在局部坐标接近0或1的问题位置精确地创建任何边缘，但就像上一节中的网格线一样，用抗锯齿的`aastep`版本替换`step`函数，会在`floor`函数的不连续处产生微弱但看似随机的瑕疵。
在我们结束这个例子之前，我们来解决这个问题。和之前一样，我们希望对称的斜坡在单元格边缘处能够平滑衔接，不出现间断。可以这样做：
```glsl
float bricks( vec2 p ) {
    vec2 q = fract( p + vec2( 0.5 * floor( p.y ), 0.0 ) ); // Staggered grid
    q = 2.0 * abs( q – 0.5 ); // Change from sawtooth to triangle
    float brickx = 1.0 – step( 0.95, q.x ); // vertical gaps at both sides
    float bricky = 1.0 – step( 0.9, q.y ); // horizontal gaps at top and bottom
    return min( brickx, bricky ); // If either is 0, return 0
}
```
因为x和y方向上的渐变现在是从砖块中间向两边边缘的向上斜坡，所以我们也可以只用一半数量的阶跃函数。也许有点出乎意料，实际上我们在提高抗锯齿效果的同时，还提高了代码的效率。
![2505021808](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/02/1mg/2505021808-.png)
*Anti-aliased brick pattern in color, rotated and scaled to make the bricks 2x wider.*

现在，我们在上一节中确实建议在处理网格线时不要使用这种阈值设置，并且该警告仍然有效。在缩小视图中，由于`aastep`计算出错误的步长，会出现伪影，从而产生砖块之间间隙大约为一个像素的大小。虽然网格线通常应该非常细，但砖块之间的灰浆线条并不一定如此，因此这段代码在很多情况下可能已经足够好了。然而，再稍微思考一下，这个残留的瑕疵也是能消除的。观察我们想要的图案，我们可以构建一个三角波映射（s，t），使得所有垂直线都位于s坐标倾斜斜坡的中心，所有水平线都位于t坐标斜坡的中心。s的代码是一行令人头疼的混乱代码，但图像应该能清楚地表明它的作用。
![2505022028](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/02/1mg/2505022028-.png)
*Mapping without problematic discontinuities for the “bricks” pattern. The green lines show where the mapping coordinate is 0.5. This is where we place the gaps.*

使用此映射创建砖块模式，代码将如下所示：
```glsl
float s = 2.0*abs(fract(0.5*(x+0.5*floor(2.0*y-0.5)))-0.5); // Finicky mapping float t = 2.0*abs(fract(y)-0.5);
float bricksx = aastep(0.475, s) - aastep(0.525, s); // s is stretched 2x float bricksy = aastep(0.45, t) - aastep(0.55, t);
float bricks = max(bricksx, bricksy);
```
有一个不那么繁琐的方法来解决这个问题——这是一种对许多其他存在类似问题的模式同样有效的解决方案，且非常轻松。然而，理解这种方法需要深入了解`aastep`的实际工作原理，所以我们继续往下讲，在下一章再回过头来讨论这个模式。

### 关于精度的说明
本章中的着色器都使用`fract`或`mod`来计算平铺的局部坐标。这存在一个潜在问题，该问题并不明显：我们取的是用浮点数表示的坐标的小数部分。这些数字的有效位数会随着数值增大而减少。

随着它们变大，小数精度会降低。从数学角度来说，平铺是无限的，但在浮点表示中，当我们在整个表面映射的坐标系中远离原点时，局部映射坐标会失去其小数精度。当坐标达到一千时，我们已经损失了十位小数精度，在大多数情况下这应该不太明显，但当我们达到一百万时，几乎就没有小数位了。因此，当表面坐标离原点很远时，许多程序生成的图案开始看起来很怪异。这些错误的一个常见原因是动画平移运行时间过长。

我们将在第15章“缩放”中回到这个问题，并更深入地探讨浮点精度相关的问题。目前，只需记住我们并非在进行精确运算。我们处理的是精度有限的数字，这可能会引发问题。

### 六边形平铺
> 译者注： 六边形平铺也可以看看我往期的公众号文章呀

另一种平铺方式是六边形平铺，我们接下来会讲到，但首先，有必要提醒一句。请不要因为与其他平铺方式相比，这种方式相对复杂而感到惊慌！六边形平铺并不完全适合映射到笛卡尔 $(x, y)$ 坐标系统，这需要一些功夫。下面展示的映射并不直观。创建它花费了相当多的精力，而我们实际上只是呈现这个过程的最终结果。不过，六边形平铺可能非常有用，所以请记住这是一种选择，并且这里有相关代码。还有其他几种创建六边形网格的有用算法，你可能会找到另一种自己最喜欢的。这里介绍的这种算法之所以被选中，是因为它既高效又相对容易解释。不是很容易，但相对容易。
![2505022446](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/02/1mg/2505022446-.png)
*一种六边形平铺的变体*

用着色器代码表达六边形平铺有点棘手。确实是棘手，因为要以高效的方式实现它需要一些技巧。首先，注意上面图表中的整数坐标以及我们对缩放比例的选择。这种平铺并非由正六边形构成——它们稍微高一些，高度是正六边形的 $\frac{2}{\sqrt{3}} \approx1.1547$ 倍。这种特定的网格选择使平铺代码更简单，可读性更强。要从这个稍微拉伸的版本创建正六边形平铺，只需将映射坐标在y方向上按 $\frac{2}{3}$ 的比例缩放，实际上就是将六边形挤压回等边比例。

以这种方向进行平铺时，连续的六边形水平行相互错开，且每隔一行是相同的。它既可以表述为交错平铺，也可以表述为斜向平铺。就此而言，六边形可以直接定义为某个特定网格点距离最近的区域。请记住，我们的目标不是得到一个用于定位平铺边界线并绘制它们的函数，而是要计算每个六边形内周期性重复的局部坐标。我们可以通过首先找到平面上任意一点 $\overrightarrow{p}=(x, y)$ 距离最近的六边形中点的位置来实现这一点。

我们将选择把网格映射到交错平铺。（将其视为斜交平铺可能效率略高，但也相当杂乱。）事实上，我们将更进一步，把交错平铺视为两个重叠的矩形平铺：
![2505023515](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/02/1mg/2505023515-.png)
*A staggered grid regarded as two rectangular grids with an offset between them.*

现在，对于平面上任意一点 $\overrightarrow{p}=(x, y)$ ，我们想确定哪个六边形中点距离它最近。如果我们能找出如何对蓝色或绿色网格中的一个单元格进行此操作就足够了，因为该算法对于所有其他单元格。观察蓝色网格中的一个单元格，我们发现对于单元格内的一个点而言，有五个可能的候选网格点与之距离最近。
![2505023603](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/02/1mg/2505023603-.png)
*蓝色网格的一个单元格，带有编号的六边形中点 $\overrightarrow{p}_{i}$ *

单元格中间一半的区域， $\overrightarrow{p}_{4}$ 是最近的，但在每个角附近，最近的点位于 $\overrightarrow{p}_{0}$ 、 $\overrightarrow{p}_{1}$ 、 $\overrightarrow{p}_{2}$ 或 $\overrightarrow{p}_{3}$ 之中。最直接的方法是计算到所有五个候选点的距离，然后选择最近的那个。但如果要高效的话，可以先确定我们处于哪个角，然后仅比较到 $\overrightarrow{p}_{4}$ 和对应角候选点的距离。

对于单元格内的点 $(x, y)$ ，左下角顶点位于 $(x_{0}, y_{0})=(\lfloor x \rfloor, 2\lfloor y/2 \rfloor)$ ，其他顶点与它有固定的偏移量。如果 $x < x_{0} + 0.5$ ，我们就在单元格的左半部分，如果 $y < y_{0} + 0.5$ ，我们就在单元格的下半部分。执行这两个测试可以确定四个角中的哪一个可能比 $\overrightarrow{p}_{4}$ 更近。符号测试特别高效，因为它们不需要进行减法运算——它们只需查看符号位来确定一个数是否为负。因此，我们根据从 $\overrightarrow{p}_{4}$ 到当前点 $\overrightarrow{p} = (x, y)$ 的向量来选择一个角。

通过进行两次简单的比较，我们现在已经排除了除两个候选点之外的所有点，以寻找最近点。我们可以直接计算到这两个点的距离并进行比较，这比计算所有五个点的距离要省事得多。

然而， $\overrightarrow{p}_{4}$ 到角的中线，并不完全是正六边形的边界。仔细观察这种情况，我们会发现，在我们拉伸的网格中，等距离线与我们期望的单元格边界有一个小角度，而且我们的单元格会稍微短粗一些。
![2505023808](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/02/1mg/2505023808-.png)
*我们想要的边界（红色）和等距中线（黑色虚线）。*

这可能不是个大问题——事实上，在某些情况下，这甚至可能正是我们想要的。我们也可以通过在非均匀缩放的坐标系中计算距离来解决这个问题，在这个坐标系中，我们将y分量压缩 $\frac{\sqrt{3}}{2} \approx0.866$ 倍。这样整个计算会和常规的、未拉伸的网格中计算欧几里得距离度量相同，并使单元格边界与我们图表中的红线匹配。这将是一个非常 OK的解决方案。

然而，注意到边界是一条直线，我们可以使用该直线的隐式方程来确定我们的点位于直线的哪一侧。千言万语汇成一个公式，如下：
$$
\left(\overrightarrow{p}-\overrightarrow{p}_{4}\right) \cdot \left( \pm \frac{2}{3}, \pm 1 \right) - \frac{2}{3} = 0
$$
其中点表示标量积，第二个向量分量的正负号取决于我们所处的角。如果这个表达式为负，则 $\overrightarrow{P}$ 距离 $\overrightarrow{p}_{4}$ 比距离 $\overrightarrow{p}_{4} + \left( \pm 0.5, \pm 1 \right)$ 处的角更近。

我们完成了！让我们将整个算法表示为程序代码
