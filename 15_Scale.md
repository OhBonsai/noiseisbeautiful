

在引言及全文的隐含表述中，我们常将程序化纹理描述为具有"无限延展性"和"任意分辨率"。这并不完全准确。虽然底层数学概念确实具备这些特性，但在计算机图形学中，我们处理的是有限精度和范围的数值计算程序，这一点必须牢记。当精度或范围不足时，会导致视觉瑕疵甚至直接错误。要理解问题本质、注意事项及解决方法，我们需要深入二进制实数表示的底层原理。

## 浮点数与双精度数的内部结构

IEEE标准的32位浮点数（现代编程语言中的**float**类型）采用尾数-指数格式$M \cdot 2^E$表示。32位中23位用于尾数$M$，通过规范化处理使得$1 \leq M < 2$。由于$M$的首位总是二进制1，实际只存储后续小数部分，开头的1被隐含表示。1位用作符号位（0正1负），剩余8位存储$E+127$的指数值。00000000和11111111保留给$NaN$等"特殊数字"，因此$E$的实际范围为$-126$至$+127$。

![2506295106 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/06/29/1mg/2506295106-.png)
*The meaning of all 32 bits in a float.*

在计算机图形学中，$2^{127}$的绝对值极大，$2^{-126}$极小，因此可表示的范围基本够用。问题在于精度——随着数值增大，尾数$M$的有效24位中越来越多用于整数部分，相应减少小数部分的位数。如果在远离纹理空间原点的位置评估程序化纹理函数，可能因精度不足产生伪影。下图展示噪声函数在$(1000,1000)$、$(10^4,10^4)$、$(10^5,10^5)$和$(10^6,10^6)$处的表现：

![2506295139 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/06/29/1mg/2506295139-.png)
*逐渐远离原点评估的噪声函数。在$10^6$单位距离处（最右），纹理坐标精度严重不足*

在$u=0$处，所有23位都是小数位，对任何分辨率都足够；$u=1000$时仍有13位小数位，除非对噪声图案大幅放大，否则多数分辨率下够用；超过此值问题逐渐显现；$u=10^6$时仅剩3位小数位（相邻整数间只有8个步长），对特征宽度约1单位的图案即使远观也不够；超过$10^7$则完全没有小数位——只能表示整数。

近年高端GPU逐渐增加对双精度浮点数（**double**类型）的支持。多数GPU处理**double**仍比**float**慢得多（全程使用**double**变量可能导致性能骤降）。**double**还需双倍存储空间和传输带宽。但由于采用52位尾数$M$，其精度显著提升——前述$10^6$单位距离处的问题，在双精度纹理坐标下要到$5 \cdot 10^{14}$单位距离才会出现。

这看似能满足所有需求，实则不然。在深入之前，我们还需了解另一种小数表示方法。

## 定点数数学

_定点表示法_是比浮点更古老的非整数表示方法，通过在比特序列中预设_二进制小数点_（相当于十进制小数点）的位置，使简单整数运算能处理小数。例如16位二进制字可用左8位表示整数部分（无符号或常规补码），右8位表示小数部分（称为"8.8表示法"）。小数部分的权重仍是2的幂次，但为负幂次。例如8位二进制小数0.101表示$2^{-1} + 2^{-3} = 0.625$。也可视为存储了放大$2^8$倍的数值。

定点运算能用整数运算单元处理：加减法与整数完全相同；乘法需注意结果缩放——8.8表示法中1是00000001(.)00000000，乘法单元会视为256，为确保$1 \times 1 = 1$，结果需除以$256 \times 256 = 65536$（相当于右移16位）。这要求计算结果保留超过16位，否则截断会丢失有效位。幸运的是，16位乘法器本就需要输出32位结果。看似耗时的位移操作实际只是字节重排，在乘法器输出端即可零成本完成，但需在每步运算后立即执行。除法则无需位移，因为分子分母的隐含缩放会相互抵消。

用常规编程语言整数变量实现的定点运算代码会充满位移操作，可读性和可写性都很差。但在某些场景仍是优选：嵌入式CPU可能不支持浮点运算，或软件模拟的浮点运算速度远慢于整数运算。许多经典计算机图形学算法（尤其是信号和图像处理领域）明确设计为仅使用整数运算，至今仍在许多场景适用。

现代GPU的某些部件内部实际使用定点表示。最典型的例子是标准8位颜色值输出和纹理采样输入，用0-255表示0-1的像素值（类似"0.8表示法"）。实际上二进制11111111(255)被精确映射为1，而非二进制0.11111111对应的0.99609375——差异虽小但重要。

许多低端GPU在纹理插值时也使用定点数。虽然纹理坐标作为通用浮点向量属性提供，但纹理单元可能采用定点插值来避免全精度浮点运算。这对基于图像的纹理极端特写视图有影响，特别是纹理数据被阈值化或高对比度渲染时。如需插值纹理采样的极高精度，可能需要绕过内置双线性插值，在着色器中显式重新实现。

最后需指出：在现代GPU编程中，整数运算通常不会加速。2025年的顶级GPU处理整数与浮点速度相当（多数硬件实际更慢）。计算机图形渲染的主体是浮点计算，硬件也为此优化。早期GLSL甚至不支持整数。

## 图形专用表示法

某些数字表示格式专为计算机图形需求设计，值得特别介绍。它们的共同点是通过精简存储空间和提高计算速度，为特定用途提供刚好足够的范围和精度。

### IEEE "half"格式

16位半精度浮点（某些语言称为**half**）采用与**float**/**double**相同的设计，但仅用5位指数、10位尾数和1位符号位。精度和范围（约$\pm 2^{16}$，精确值为$\pm 65504$）虽有限，但足够特定用途。OpenEXR视频格式用**half**存储颜色值；神经计算也广泛采用——它们不需要高精度，但追求速度和紧凑性。

性能尚可的现代GPU中，纹理各通道可用16位**half**格式存储。对多数图形应用属于过度设计，但若需扩展精度和范围，这无论是纹理输入还是像素输出都是最自然的选择。

### OpenGL "R10G10B10A2"格式

在OpenGL和Direct3D中存在一种定点纹理格式，其中RGB通道各占10位，Alpha通道仅占2位。采样时所有通道被映射到$[0,1]$范围。OpenGL还包含无Alpha通道的"R11G11B10"变体，R/G通道各11位，B通道10位。这些格式通过提升色彩值精度，有效避免了在现代高亮度数字显示器上使用8位数据显示平滑渐变时出现的色带问题。

8位表示像素值在1980年代是合理选择——当时计算机内存以KB而非GB计，显示器是模拟信号、昏暗且带噪点。但如今这已远远不够，甚至对于需要后期编辑、对比度增强、强度缩放和色彩校正的中间图像存储也从未足够，现在8位强度编码连直接显示都捉襟见肘。

### OpenGL "R9G9B9E5"格式

OpenGL还有一种特殊的RGB纹理浮点类型，三个通道共享同一个指数位。每个通道占9位，指数占5位。该格式没有符号位，因为用于表示光强值（永不为负）。共享指数看似奇怪，但对色彩通道很有意义——当某个通道值较小时，其精度会降低甚至归零，但这些相对较小的值对整体色彩影响本就有限。这种纹理格式虽不常用，但设计理念值得借鉴。

### Radiance "RGBE"格式

早期*高动态范围*(HDR)成像广泛使用的RGBE格式至今仍有价值。这种4通道纹理不将数据视为RGB+透明度，而是将RGB存储为8位无符号整数，外加8位有符号指数E表示二进制小数点位移。每通道8位的设计使其能兼容PNG等标准RGBA图像存储格式，从而将HDR图像"塞入"Web页面等本不支持的环境（如通过JavaScript加载图像数据并发送到WebGL着色器进行动态色调映射）。但需注意避免对RGBE数据使用有损压缩——因为E通道最低有效位的改变意味着强度2倍的变化，即便是JPEG高质量压缩对单个RGB像素的微小（通常不可察觉）调整，若该像素恰好具有较大指数值，也可能造成巨大影响。

##  行星级尺度

计算机图形学旨在模拟现实外观，而现实的显著特征就是...庞大。它还具有丰富细节，许多应用需要自由缩放视角，让近处和远处物体同时出现在屏幕上。这带来了难题——所有计算机数字表示法都在分辨率和范围间有所取舍。

以地球或类似尺寸行星模型为例，自然选择是将局部坐标系原点设在球心，直接使用3D位置或通过某种2D映射创建纹理坐标。经纬度映射可行但在两极存在严重尺度不均和收缩问题，更好的选择是用六面立方体贴图包裹球体。虽然使用**float**变量存储坐标和执行变换看似自然，但如果需要缩放至行星表面渲染视图，这就绝非好选择。

对于半径6,400公里的类地行星，表面所有点至少有一个$(x,y,z)$坐标达到该量级，若创建显式2D纹理坐标，立方体贴图需覆盖至少10,000公里范围（经纬度坐标需要更大）。用32位**float**表示时，如此大的数值仅有0.5米精度。不同坐标分量精度各异，且在整个表面差异显著。这种精度将制约我们在行星表面进行的任何操作——地形位移、纹理映射甚至简单场景物体放置。不用说，0.5米的纹理坐标精度对特写视图远远不够，如此糟糕的物体坐标精度也无法建模细节或实现平滑运动。

通过精心设计变换，我们可以使用局部原点而非行星中心的全局原点。传统计算机图形视图变换将"相机"坐标系原点设在观察者位置。对于行星级物体，尽早（在添加任何细节前）转换到该坐标空间进行所有操作是明智之举。足够谨慎的实现能确保坐标系精度在相机附近保持充足，仅在通常不需要高精度的远处降低。

生成程序化行星的软件通常将物体空间坐标原点设在行星表面某处，这能避免早期变换到视图空间的需求。*望远镜视图*（长观测距离搭配窄视野，如模拟卫星视图）的简单实现也会引发问题——此类视图最好不用中心透视投影，而采用原点设在目标位置（非相机位置）的正交投影模拟。

使用**double**变量存储行星表面坐标时，10,000公里量级的数值具有亚原子级分辨率，完全满足需求。即使以太阳系中心为原点建模整个太阳系，仍能保持行星表面的亚毫米级精度。但**double**变量仍有可观成本，应尽可能避免。况且若要建模银河系甚至宇宙，同时保证能以人类尺度精确呈现遥远行星表面，即使双精度变量也不够用。虽然存在使用128位甚至256位的扩展精度格式，但它们甚至不被普通CPU直接支持，更不用说GPU硬件。

总结：在行星级及以上尺度，选择合适的视图相关局部原点至关重要。

<div style="text-align:center; font-size:1.2em; margin:20px 0;">
<span style="display:block; font-weight:bold;">"飞向宇宙，浩瀚无垠！"</span>
<span style="display:block; font-style:italic; margin-top:8px;">
巴斯光年
</span>
</div>
