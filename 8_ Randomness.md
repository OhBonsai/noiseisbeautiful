
真正的随机数很难生成。自计算机发明以来，软件一直使用看似随机的函数，从某种意义上说，这些函数具有真正随机数的可观测统计特性。然而，软件中实现的 “随机数生成器” 实际上是伪随机的。（“Pseudo” 在拉丁语中是 “假的” 意思。没错，就是字面意思。）这些算法输出的是一个确定性序列，只是经过了高度的混淆。这个序列也是重复的，尽管重复周期实际上可能非常长。 

## 伪随机数

伪随机数生成器有一个内部状态，该状态唯一地决定序列中的下一个数字，并且该状态会随着结果进行更新，以使下一个数字不同。然而，如果知道算法和内部状态，另一台计算机就有可能重现完全相同的序列。同一生成器不同副本之间的 “随机” 变化是通过选择不同的种子来实现的，种子实际上就是内部状态。在一些经典算法中，种子仅仅是前一个伪随机数的值。 

对于接近真正随机性的情况，可以给伪随机数生成器一个种子，该种子取决于某些现实世界的属性，就当前目的而言，这些属性实际上是随机的。计算机大多能非常精确地记录一天中的时间，当人类用户选择运行一个程序时，程序启动时时钟上微秒数的低位比特是一个真正的随机数（在那种情况下），可以用作种子。其他策略是从一些鼠标输入或人工操作员几次按键的确切时间来生成种子。 

## 哈希函数

在程序化方法中，我们所需要的并非通常意义上的伪随机性。相反，我们需要的是可重复性：当一个着色器使用相同的输入再次执行时，它所产生的结果应与上一次完全相同。对于重新渲染、分布式渲染以及并行渲染而言，这一点绝对是必不可少的，因为只有这样，图案在动画过程中才能保持一致。而且，对于从艺术层面把控程序化图案的细节外观来说，这一点也极为重要。一旦你在某种特定情形下为一个伪随机图案找到了自己心仪的效果，你就会希望它能始终保持原样。正因为如此，伪随机数本身在着色器中并不是特别有用，这是由于它们具有 “随机性”。不过，那种随机性其实只不过是一种错觉罢了。但我们可以利用这一点

着色器函数可以使用类似于随机数生成器的工具，但要提供一个确定性种子。该种子应仅取决于场景中的确定性参数：纹理坐标以及某些表面或对象ID，或者是用户可选的常量。然后，一个合适的算法应该能够对种子进行充分的混淆，以掩盖其生成的“随机”值背后的确定性本质。此类函数通常称为哈希函数，简称哈希。 

要在点采样场景中发挥作用，用于程序纹理的哈希函数通常在规则网格中的整数坐标上运行，并且在网格单元内哈希值保持不变。GLSL或任何其他当前的GPU着色语言中都没有任何类型的内置哈希函数，但在RSL和OSL中，有一个名为cellnoise(x,y)的内置哈希函数，它为1×1正方形网格中的每个单元格返回一个看似随机（但实际上是确定性）的值：

![2505050304 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/05/1mg/2505050304-.png)
*OSL cellnoise(x,y): a “random” value in [0,1] for each (floor( x), floor( y)).*

OSL语言规范并未确切说明用于细胞噪声哈希的具体算法，并且让着色器依赖于确切值是不明智的。可以保证在同一平台上的多次渲染中具有可重复性，但不同平台之间（例如两个都支持OSL着色器的不同渲染器）则无法保证匹配。如果你想要这种可重复性，即使在像cellnoise这样的内置函数可用的环境中，也需要在着色器代码中创建自己的哈希函数。 

## 置换表 Permutation tables 

哈希函数在计算机科学中的应用远远超出了程序模式这一狭窄领域，而且我们不必为了这个特定目的去发明它们。然而，当我们从其他领域借用哈希函数时需要记住的是，我们追求的不是高质量，而是速度和易用性。怎样才算足够的质量取决于具体情况，但我们常常可以使用（从正式统计标准来看）质量出奇差的哈希函数，却仍然能创建出视觉上令人愉悦的看似随机的图案。 

几十年前常用的一种技巧是使用置换表，它不过是一个数字顺序打乱的数组。许多作者使用一个包含0到255之间256个数字的表，通过反复试验重新排列以消除不良的规律性。然而，查找表需要进行内存访问才能使用。在许多用于着色器执行的现代环境中，即使在软件渲染中，内存访问的代价也可能相当高。

幸运的是，有几种方法可以即时生成排列和哈希值。实际上，方法太多，无法在此全部涵盖，因此我们将只讨论四种特定的变体，选择它们是因为它们采用了截然不同的方法。

## 整数哈希 Integer hash
经典的随机数生成器，就是那种你通常会在大多数编程语言中作为库函数实现的，函数名类似rand或random的生成器，通常使用一个内部状态，而这个内部状态只是一个整数，通过提供一个种子值，你就能精确设置这个整数的值。这些rand函数的统计质量在不同实现之间差异很大，但大多数都更注重速度而非质量。如果你想要更好的伪随机性，内置函数并没有什么神奇之处——它只是软件，你可以使用任何你想要的算法来实现自己的随机数生成器。 
作为此类函数的唯一示例，我们介绍PCG哈希，其中PCG是“排列同余生成器”（permuted congruential generator）的缩写，这一概念最初由梅利莎·奥尼尔（Melissa O’Neill）于2014年提出[https://www.cs.hmc.edu/tr/hmc-cs-2014-0905.pdf]，现在被许多作者用作计算机图形学的哈希算法。尽管它很简单，但在大多数情况下都具有出色的统计特性：
```
uint pcg_hash(uint input) {
	uint state = input * 747796405u + 2891336453u;
	 uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
	 return (word >> 22u) ^ word;
}
```
二维哈希可以通过重复调用哈希函数来实现，采用的策略是`hash(x, y)=hash(hash(x)+ y)`，但这个函数具有足够的“随机性”，允许将x和y分量合并并一次性计算哈希值： 
```
// 2-D cellnoise by two nested calls to pcg_hash
float cellnoise_pcg2(vec2 p) {
	uvec2 pu = uvec2( ivec2( floor( p ) ) & ivec2( 0x7FFFFFFF ) );
	return float( pcg_hash( pu.x + pcg_hash( pu.y) ) & 0xFFFFu ) / 65536.0;
}
// 2-D cellnoise by a single call to pcg_hash and an ad-hoc combo of x and y
float cellnoise_pcg1(vec2 p) {
	uvec2 pu = uvec2( ivec2( floor(p) ) & ivec2( 0x7FFFFFFF ) );
	return float( pcg_hash( pu.x + pu.y * 289u) & 0xFFFFu) / 65536.0;
}
```

我们选择的PCG算法使用无符号整数（uint），从浮点数到无符号整数的转换是通过整数和位掩码（一种“二进制取模”操作）来实现的，这样可以去掉符号位，并将负整数转换为正整数。如果我们直接从浮点数转换为无符号整数，那么这种细胞噪声算法对于负整数将会失效。同样的位掩码技巧也用于返回值，以屏蔽无符号整数的高位比特。浮点数在不损失精度的情况下无法存储更大的32位无符号整数，而哈希值中精度的损失会导致我们得到更少的唯一值。 
这些函数中的位运算和整数数学运算在某些GPU上可能会非常慢。在你大量使用这些函数之前，你可能需要测试一下它们的性能。


## 浮点哈希

不幸的是，整数在某些GPU中仍然是二等公民，得到的支持很弱甚至不存在。传统CPU在执行整数算术运算时，往往比执行浮点值（在许多编程语言中标准类型名为float和double）的运算速度快得多，因为硬件中的位级操作对于整数运算来说要简单得多。用于嵌入式系统的低端CPU在硬件中甚至仍然没有浮点运算支持。 

有了可编程着色器的GPU，起初情况正好相反：浮点运算对计算机图形至关重要，但整数运算并非如此，因此着色语言只有浮点类型，并且仅提供32位的“单精度”变体（float）。GPU仍然是为渲染图像而设计的，尽管高端型号现在也兼作通用计算设备。许多低端型号对64位“双精度”浮点（double）的支持较弱或根本不支持，即使是当今最好的GPU也是如此，使用单精度浮点数（float）比使用双精度浮点数（double）要快得多。一些移动GPU甚至使用比32位更低的精度来处理GLSL中仍称为float类型的数据。并非所有平台都支持整数运算，即使支持，其性能通常也低于浮点运算。

因此，拥有一个仅使用浮点运算的哈希函数仍然很有用。传统整数哈希中常见的一些操作，如位移和异或操作，在浮点运算中根本不存在，所以我们需要一种不同的策略。我们想要的是一种算法，它将整数值的浮点数作为输入，并返回一个相当随机的数字。为了计算多维哈希，如果返回值也是一个整数值的浮点数，那会很有用，因为这样我们就可以通过两次调用一维哈希函数来计算二维哈希，即 hash(x, y)=hash(hash(x)+ y)。 

### 置换多项式 Permutation polynomials

有一种算法，如果你精心对其进行调整，它的效果会相当不错，那就是使用置换多项式。置换多项式是一类能对模N的连续整数序列进行置换的多项式。如果输入的数字是$\{0, 1, 2, 3, \ldots, N - 1\}$，那么输出的数字还是这些，但顺序不同。

我们不会深入探讨这种算法的工作原理、为何能起作用，也不会确切地说明如何构造一个置换多项式，但了解以下这点可能会有帮助：对于形式为$p(x) = (2Ax^2 + Bx) \bmod A^2$的二次多项式，其中A是一个质数，这类多项式必定是置换多项式。二次多项式很容易计算，而且非常适合仅支持浮点数运算或偏向浮点数运算的硬件。如果输入值是均匀分布的，那么输出值也会是均匀分布的。并且，如果你不是特别挑剔的话，这

种哈希的统计特性对于许多应用来说已经足够好了。对于我们的需求而言，一个表现出不错 “随机性” 的函数是$p(x) = (34x^2 + 10x) \bmod 289$：
```glsl
// 质量尚可的简单一维浮点数哈希函数
float permute289( float x ) {
    float h = mod( x, 289.0 );
    return mod( ( 34.0 * h + 10.0 ) * h, 289.0); // 34x^2 + 10x mod 289
}
// 仅使用浮点数运算、质量尚可的二维细胞噪声函数
float cellnoise_perm( vec2 p ) {
    return permute289( permute289( p.x ) + p.y ) / 288.0; // 取值范围 [0,1]
}
```

### 无用位Hash  Trash bits hash

最后，由于像这样的方法在各种论坛上流传且经久不衰，我们给出这个勉强能用的二维哈希函数：
```glsl
// 极其糟糕的二维细胞噪声函数
float cellnoise_sin( vec2 p ) {
    return fract( sin( dot( p, vec2(12.9898, 78.233) ) ) * 43758.5453 );
}
```
乍一看，调用一次正弦函数，再加上一些奇怪的缩放，怎么就能产生哪怕稍微有点像随机的结果，这简直是个谜，但问题就出在细节上。用向量$(12.9898, 78.233)$做点积，是一种将$x$和$y$分量合并为一个值的方法，这样至少在你不仔细观察的情况下，可能不会产生太明显的方向瑕疵。在取小数部分$(fract）$之前乘以$43758.5453$进行放大，这是一个技巧，它会去掉正弦函数值的所有高位位，并在一定程度上打乱剩下的低位位。在当前的 GLSL 实现中，正弦函数是通过一种为了速度而非精度设计的数值近似方法来计算的。将值大幅放大，然后去掉整数部分，就只剩下 “无用位”，也就是本质上有点随机的低位位，而且希望这些位没有明显可见的周期性。

这段代码很紧凑，运行速度也相当快，但存在严重的缺点。它故意利用正弦函数数值近似结果中的低位 “无用” 位来计算主要结果，这是对正弦函数的滥用。正弦函数算法的细节没有文档记录，可能会在毫无通知的情况下发生变化，并且结果会因平台而异。输出值的分布不均匀，而且输出中存在方向和周期性的瑕疵。这是一种不可预测、糟糕的方法，你真的不应该使用它。很多人在他们的示例中使用了它，但这并不意味着它就是正确的。它不是特别快，甚至也不好用。当把它渲染成一种图案时，会出现条纹和周期性瑕疵，这是因为最初的点积运算试图节省一次正弦函数调用所导致的。对于二维细胞噪声来说，一个更好的函数是使用两次哈希：
```glsl
// 臭名昭著的 “取小数-正弦哈希”，一种只是偶然有效的方法
float sin_hash( float x ) {
    return fract( sin( floor(x) * 12.9898 ) * 43758.5453 );
}
// 通过两次嵌套调用上述糟糕的哈希函数实现的二维细胞噪声函数
float cellnoise_sin2( vec2 p ) {
    return sin_hash( sin_hash( p.x ) * 78.233 + floor( p.y ) );
}
```
然而，当我们这么做时，相较于置换多项式的速度优势就消失了。一个简单的置换多项式只需要几次乘法运算（在我们的例子中是四次，包括在取模调用中与1/289的固有乘法运算），并且在大多数GPU架构上，其实际计算速度更快，尽管正弦函数是硬件加速的。源代码层面的简洁性并不一定意味着执行速度快，而且简洁的源代码本身也并非是我们要追求的目标。在着色器编程中，重要的是输出质量、在目标GPU平台上的执行速度，以及和所有编程一样，代码的可读性。 

### 临时浮点数哈希 Ad-hoc float hash

我们可以对分量$(x, y)$进行一系列非线性但仍相对简单的算术运算，然后对运算结果使用取小数部分$fract$函数，而不是利用正弦函数的无用位。下面这个特定的函数是戴夫·霍斯金斯（Dave Hoskins）在Shadertoy网站[https://www.shadertoy.com/view/4djSRW]上提出的：
```glsl
// 戴夫·霍斯金斯在Shadertoy上提出的“无正弦”取小数哈希函数之一
float hash12(vec2 p) {
    vec3 p3 = fract(vec3(p.xyx) * 0.1031);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}
// 使用上述哈希函数的一个出奇好的细胞噪声函数
float cellnoise_hoskins( vec2 p ) {
    return hash12(floor(p));
}
```
这有点像是x和y的混合三次多项式，并且效果相当不错。与置换多项式哈希函数相比，它需要多进行几次乘法运算，但它仍然比利用正弦函数的那种取巧方法更快、更好。不要使用那种利用正弦函数的取巧方法。那种方法很糟糕。你的朋友、同事和宠物都会因此而疏远你。

总之，我们对上面介绍的几种细胞噪声变体进行了可视化比较。要确切地说出这些变体的相对执行速度是不可能的，因为不同的图形处理器（GPU）之间存在巨大差异。有些根本无法处理整数运算，有些处理起来速度极慢，而有些则处理得很好。正弦函数在速度和（不）准确性方面也有很大差异。我们能给出的最好建议就是 “尝试一些其他方法”。

![2505055511 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/05/1mg/2505055511-.png)
*2-D cellnoise implemented with “trash bit hash” using the sin function.
左图：一次合并调用。右图：两次嵌套调用。只有在进行两次嵌套调用时质量才勉强说得过去，但即便如此，我们仍能看到一些大规模的图案瑕疵。*

![2505055548 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/05/1mg/2505055548-.png)
*Left: permutation polynomials. Right: Hoskins’ ad-hoc (but good) hash.
置换多项式的效果尚可，但可能存在有问题的瑕疵。霍斯金斯的临时哈希函数在这方面的表现出奇地好。
在大多数现代图形处理器（GPU）上，这两种方法的执行速度都比 “利用正弦函数的取巧方法” 要快。*


![2505055616 ](https://blogimgbeg.oss-cn-shanghai.aliyuncs.com/2025/05/05/1mg/2505055616-.png)
*2-D cellnoise implemented with the PCG hash function.
左图：通过临时方式合并x和y的一次调用。右图：两次嵌套调用。两种情况下的质量都非常好。在对整数支持良好的现代图形处理器上，这种方法的执行速度可能比上述的浮点数哈希函数还要快。值得一试。
